This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-08T04:32:18.353Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    ci.yml
cli/
  src/
    main.rs
  Cargo.toml
lib/
  src/
    provider/
      context.rs
      mod.rs
    transport/
      ble.rs
      mod.rs
      tcp.rs
      usb.rs
    device.rs
    error.rs
    info.rs
    lib.rs
  Cargo.toml
proto/
  src/
    apdus/
      app_info.rs
      device_info.rs
      exit_app.rs
      mod.rs
      run_app.rs
    error.rs
    lib.rs
    status.rs
  Cargo.toml
sim/
  src/
    drivers/
      docker.rs
      local.rs
      mod.rs
    handle.rs
    lib.rs
    main.rs
  Cargo.toml
.gitignore
Cargo.toml
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/ci.yml
================
name: ci

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  # Run lints / checks
  lint:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        submodules: true
        fetch-depth: 0

    - name: Configure toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
        override: true
        components: rustfmt, clippy, rust-src

    - name: Install comms libraries
      run: sudo apt update && sudo apt install -y libusb-1.0-0 libusb-1.0-0-dev libudev-dev libdbus-1-dev pkg-config

    - name: Restore shared cache
      uses: actions/cache/restore@v3
      with:
        key: core
        path: |
          ~/.cargo
          ./target

    - name: Check formatting
      uses: actions-rs/cargo@v1
      with:
        command: fmt
        args: --check

    - name: Run clippy
      uses: actions-rs/cargo@v1
      with:
        command: clippy
        args: -- -D warnings

  # Check no_std build of protocol objects
  check:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
          fetch-depth: 0

      - name: Configure toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true
          target: thumbv7em-none-eabihf

      - name: Restore shared cache
        uses: actions/cache/restore@v3
        with:
          key: core
          path: |
            ~/.cargo
            ./target

      - name: Check no_std build with alloc
        uses: actions-rs/cargo@v1
        with:
          command: check
          args: -p ledger-proto --target=thumbv7em-none-eabihf --no-default-features --features=alloc

      - name: Check no_std build without alloc
        uses: actions-rs/cargo@v1
        with:
          command: check
          args: -p ledger-proto --target=thumbv7em-none-eabihf --no-default-features

  # Run tests
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        submodules: true
        fetch-depth: 0

    - name: Configure toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
        override: true
        components: rustfmt, clippy, rust-src

    - name: Install comms libraries
      run: sudo apt update && sudo apt install -y libusb-1.0-0 libusb-1.0-0-dev libudev-dev libdbus-1-dev pkg-config

    - name: Restore shared cache
      uses: actions/cache/restore@v3
      with:
        key: core
        path: |
          ~/.cargo
          ./target

    - name: Run tests
      uses: actions-rs/cargo@v1
      with:
        command: test

    - name: Update shared cache, only from `main`
      if: ${{ github.ref == 'refs/heads/main' }}
      uses: actions/cache/save@v3
      with:
        key: core-${{ github.run_id }}
        path: |
          ~/.cargo
          ./target

  # Build docs
  docs:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pages: write

    steps:
    - uses: actions/checkout@v3
      with:
        submodules: true
        fetch-depth: 0

    - name: Configure toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
        override: true
        components: rustfmt, clippy, rust-src

    - name: Install comms libraries (required for build)
      run: sudo apt update && sudo apt install -y libusb-1.0-0 libusb-1.0-0-dev libudev-dev libdbus-1-dev pkg-config
    
    - name: Restore shared cache
      uses: actions/cache/restore@v3
      with:
        key: core
        path: |
          ~/.cargo
          ./target

    - name: Build docs
      uses: actions-rs/cargo@v1
      with:
        command: doc
        args: --no-deps --workspace
    
    - name: Deploy docs to GitHub Pages
      uses: crazy-max/ghaction-github-pages@v3
      if: github.ref_name == 'main'
      with:
        target_branch: gh-pages
        build_dir: target/doc
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: cli/src/main.rs
================
//! Ledger CLI, a basic command line interface for interacting with Ledger hardware wallets.
//!
//! See [ledger_lib] for APIs used in this application.

use std::str::FromStr;

use clap::Parser;
use hex::ToHex;
use tracing::{debug, error};
use tracing_subscriber::{filter::LevelFilter, EnvFilter, FmtSubscriber};

use ledger_lib::{
    launch_app, Device, Error, Filters, LedgerHandle, LedgerInfo, LedgerProvider, Transport,
};
use ledger_proto::{ApduHeader, GenericApdu, StatusCode};

/// Ledger Hardware Wallet Command Line Interface
#[derive(Clone, Debug, PartialEq, Parser)]
pub struct Args {
    #[clap(subcommand)]
    cmd: Command,

    /// Device index where multiple devices are available
    #[clap(long, default_value = "0")]
    index: usize,

    /// Filters for use when connecting to devices
    #[clap(long, default_value = "any")]
    filters: Filters,

    /// Timeout for device requests
    #[clap(long, default_value = "3s")]
    timeout: humantime::Duration,

    /// Enable verbose logging
    #[clap(long, default_value = "debug")]
    log_level: LevelFilter,
}

/// CLI subcommands
#[derive(Clone, Debug, PartialEq, Parser)]
pub enum Command {
    /// List available ledger devices
    List,
    /// Fetch application info
    AppInfo,
    /// Fetch device info
    DeviceInfo,
    /// Exchange a raw APDU with the device
    Apdu {
        /// APDU class
        #[clap(long, value_parser=u8_parse_maybe_hex)]
        cla: u8,

        /// APDU instruction
        #[clap(long, value_parser=u8_parse_maybe_hex)]
        ins: u8,

        /// P1 value
        #[clap(long, value_parser=u8_parse_maybe_hex, default_value_t=0)]
        p1: u8,

        /// P2 value
        #[clap(long, value_parser=u8_parse_maybe_hex, default_value_t=0)]
        p2: u8,

        /// Hex encoded APDU data
        #[clap(default_value = "")]
        data: ApduData,
    },
    /// Exchange raw data with the device
    File {
        #[clap(help = "file to read APDU data from (header + data)")]
        filename: String,
    },
    /// Run an application on the device
    Run {
        /// Application name
        #[clap(long)]
        app_name: String,
    },
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ApduData(Vec<u8>);

impl FromStr for ApduData {
    type Err = hex::FromHexError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let v = hex::decode(s)?;
        Ok(Self(v))
    }
}

fn u8_parse_maybe_hex(s: &str) -> Result<u8, std::num::ParseIntError> {
    if let Some(s) = s.strip_prefix("0x") {
        u8::from_str_radix(s, 16)
    } else {
        s.parse::<u8>()
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load command line arguments
    let args = Args::parse();

    // Setup logging
    let filter = EnvFilter::from_default_env()
        .add_directive("hyper=warn".parse()?)
        .add_directive("rocket=warn".parse()?)
        .add_directive("btleplug=warn".parse()?)
        .add_directive(args.log_level.into());

    let _ = FmtSubscriber::builder()
        .compact()
        .without_time()
        .with_max_level(args.log_level)
        .with_env_filter(filter)
        .try_init();

    debug!("args: {:?}", args);

    // Initialise provider
    let mut p = LedgerProvider::init().await;

    // Fetch list of available devices
    let devices = p.list(args.filters).await?;

    // Handle commands
    match args.cmd {
        Command::List => {
            println!("devices:");
            for (i, d) in devices.iter().enumerate() {
                println!("  {i} {} ({})", d.model, d.conn);
            }
        }
        Command::AppInfo => {
            let mut d = connect(&mut p, &devices, args.index).await?;
            let i = d.app_info(args.timeout.into()).await?;

            println!("app info: {:?}", i);
        }
        Command::DeviceInfo => {
            let mut d = connect(&mut p, &devices, args.index).await?;
            let i = d.device_info(args.timeout.into()).await?;

            println!("device info: {:?}", i);
        }
        Command::Run { app_name } => {
            // Check we have at least one device
            if devices.is_empty() {
                return Err(anyhow::Error::from(Error::NoDevices));
            }

            // Check we have a device matching the index specified
            if args.index > devices.len() {
                return Err(anyhow::Error::from(Error::InvalidDeviceIndex(args.index)));
            }

            let info = devices[args.index].clone();

            println!("launch app: {app_name}");

            let mut d = launch_app(
                &mut p,
                info,
                &app_name,
                &Default::default(),
                args.timeout.into(),
            )
            .await?;

            let i = d.app_info(args.timeout.into()).await?;

            println!("running app: {i:?}");
        }
        Command::Apdu {
            cla,
            ins,
            p1,
            p2,
            data,
        } => {
            let req = GenericApdu {
                header: ApduHeader { cla, ins, p1, p2 },
                data: data.0,
            };

            let mut d = connect(&mut p, &devices, args.index).await?;

            let mut buff = [0u8; 256];
            let resp = d
                .request::<GenericApdu>(req, &mut buff, args.timeout.into())
                .await?;

            println!("Response: {}", resp.data.encode_hex::<String>());
        }
        Command::File { filename } => {
            // Load APDU sequence file
            let data = std::fs::read_to_string(filename)?;
            let apdu_seq: Vec<GenericApdu> = serde_json::from_str(data.as_str())?;

            // Connect to device
            let mut d = connect(&mut p, &devices, args.index).await?;
            let mut buff = [0u8; 256];

            // Execute APDU sequence
            for apdu_input in apdu_seq {
                let resp = d
                    .request::<GenericApdu>(apdu_input, &mut buff, args.timeout.into())
                    .await;

                match resp {
                    Ok(apdu_output) => {
                        println!("Response: {}", apdu_output.data.encode_hex::<String>())
                    }
                    Err(Error::Status(StatusCode::Ok)) => println!("App OK"),
                    Err(e) => println!("Command failed: {e:?}"),
                }
            }
        }
    }
    Ok(())
}

/// Connect to a device with the provided index
async fn connect(
    p: &mut LedgerProvider,
    devices: &[LedgerInfo],
    index: usize,
) -> Result<LedgerHandle, Error> {
    // Check we have at least one device
    if devices.is_empty() {
        return Err(Error::NoDevices);
    }

    // Check we have a device matching the index specified
    if index > devices.len() {
        return Err(Error::InvalidDeviceIndex(index));
    }

    let d = &devices[index];
    debug!("Connecting to device: {:?}", d);

    // Connect to the device using the index offset
    match p.connect(d.clone()).await {
        Ok(v) => Ok(v),
        Err(e) => {
            error!("Failed to connect to device {:?}: {:?}", d, e);
            Err(e)
        }
    }
}

================
File: cli/Cargo.toml
================
[package]
name = "ledger-cli"
description = "Ledger hardware wallet command line interface"
repository = "https://github.com/ledger-community/rust-ledger.git"
keywords = [ "ledger", "wallet", "cli" ]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"

[dependencies]
clap = { version = "4.2.2", features = [ "derive" ] }
anyhow = "1.0.70"
tracing = "0.1.37"
tracing-subscriber = { version = "0.3.16", features = ["env-filter"] }
tokio = { version = "1.27.0", features = ["full"] }
time = { version = "0.3.21", features = [ "macros" ] }
humantime = "2.1.0"
hex = "0.4.3"
serde_json = "1.0.100"

ledger-lib = { version =  "0.1.0", features = [ "clap" ] }
ledger-proto = { version = "0.1.0" }

================
File: lib/src/provider/context.rs
================
use std::collections::HashMap;

use tokio::{
    runtime::Builder,
    sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},
    task::LocalSet,
};
use tracing::{debug, error, warn};

use crate::{
    error::Error,
    provider::{LedgerReq, LedgerResp, ReqChannel},
    transport::{GenericDevice, GenericTransport, Transport},
    Exchange,
};

/// Context for provider task
struct ProviderImpl {
    /// Transport for communicating with devices
    t: GenericTransport,
    /// Channel for receiving requests
    req_rx: UnboundedReceiver<(LedgerReq, UnboundedSender<LedgerResp>)>,
    /// Storage for connected devices
    devices: HashMap<usize, GenericDevice>,
    /// Index for device connections
    device_index: usize,
}

/// Static provider context, provides a global singleton for ledger device comms
pub struct ProviderContext {
    /// Channel for sending requests to the provider task
    req_tx: ReqChannel,
}

impl ProviderContext {
    /// Create a new provider context with a thread-pinned task for managing ledger operations
    pub async fn new() -> Self {
        // Setup channel for interacting with the pinned provider task
        let (req_tx, req_rx) = unbounded_channel::<(LedgerReq, UnboundedSender<LedgerResp>)>();

        // Setup runtime with local set just for this task
        // Required for 'ProviderCtx::new' to be callable from withing a `tokio::spawn` context,
        // see: https://docs.rs/tokio/latest/tokio/task/struct.LocalSet.html#use-inside-tokiospawn
        let rt = Builder::new_current_thread()
            .enable_all()
            .build()
            .expect("Failed to create runtime");

        // Spawn a new _real_ thread using this runtime
        std::thread::spawn(move || {
            // Setup local set for this thread
            let local = LocalSet::new();

            // Setup _pinned_ local task for interacting with devices
            // (HidApi and other libraries are not thread safe / okay with changing threads)
            local.spawn_local(async move {
                // Setup ledger provider task
                let mut p = match ProviderImpl::new(req_rx).await {
                    Ok(v) => v,
                    Err(e) => {
                        error!("Failed to initialise ledger task: {:?}", e);
                        return;
                    }
                };

                // Run provide task
                p.run().await;
            });

            rt.block_on(local);
        });

        Self { req_tx }
    }

    /// Fetch request channel for interacting with the provider task
    pub fn req_tx(&self) -> ReqChannel {
        self.req_tx.clone()
    }
}

impl ProviderImpl {
    /// Create provider instance
    pub async fn new(
        req_rx: UnboundedReceiver<(LedgerReq, UnboundedSender<LedgerResp>)>,
    ) -> Result<Self, Error> {
        // Setup transport
        let t = match GenericTransport::new().await {
            Ok(v) => v,
            Err(e) => {
                error!("Failed to create transport: {}", e);
                return Err(Error::Unknown);
            }
        };

        Ok(Self {
            t,
            req_rx,
            devices: HashMap::new(),
            device_index: 0,
        })
    }

    /// Run provider task
    pub async fn run(&mut self) {
        debug!("Starting ledger provider task");

        // Poll on incoming requests
        while let Some((req, tx)) = self.req_rx.recv().await {
            debug!("LedgerProvider request: {:02x?}", req);

            if let Some(resp) = self.handle_req(&req).await {
                debug!("LedgerProvider response: {:02x?}", resp);

                if let Err(e) = tx.send(resp) {
                    error!("Failed to forward response: {}", e);
                }
            }
        }

        debug!("Exiting ledger provider task");
    }

    /// Handle incoming requests and generate responses
    async fn handle_req(&mut self, req: &LedgerReq) -> Option<LedgerResp> {
        let resp = match req {
            // List devices using the provided filters
            LedgerReq::List(filters) => match self.t.list(*filters).await {
                Ok(i) => LedgerResp::Devices(i),
                Err(e) => LedgerResp::Error(e),
            },
            // Connect to a specific device
            LedgerReq::Connect(info) => {
                // Check whether we already have a handle for this device
                if let Some((k, d)) = self.devices.iter().find(|(_k, v)| v.info() == info.conn) {
                    let k = *k;
                    debug!("Found existing handle {}: {:?}", k, info);

                    let c = d.is_connected().await;

                    // Check whether handle is still active / available
                    match c {
                        // If the handle is available and in-use, return an error
                        Ok(true) => {
                            warn!("Device {k} already in use");
                            return Some(LedgerResp::Error(Error::DeviceInUse));
                        }
                        // Otherwise, drop the handle and continue connection
                        Ok(false) => {
                            debug!("Handle {k} disconnected");
                            self.devices.remove(&k);
                        }
                        Err(e) => {
                            error!("Failed to fetch disconnected state: {e:?}");
                            self.devices.remove(&k);
                        }
                    }
                }

                // Connect to the device
                let d = match self.t.connect(info.clone()).await {
                    Ok(d) => d,
                    Err(e) => {
                        error!("Failed to connect to device: {}", e);
                        return Some(LedgerResp::Error(e));
                    }
                };

                // Add connected device to internal tracking
                let index = self.device_index;
                self.device_index = self.device_index.wrapping_add(1);

                debug!("Connected device {index}: {}", d.info());

                self.devices.insert(index, d);

                // Return device handle
                LedgerResp::Handle(index)
            }
            LedgerReq::Req(index, apdu, timeout) => {
                // Fetch device handle
                let d = match self.devices.get_mut(index) {
                    Some(d) => d,
                    None => {
                        error!("Attempted to send APDU to unknown device handle: {}", index);
                        return Some(LedgerResp::Error(Error::Unknown));
                    }
                };

                // Issue APDU request to device and return response
                match Exchange::exchange(d, apdu, *timeout).await {
                    Ok(r) => LedgerResp::Resp(r),
                    Err(e) => LedgerResp::Error(e),
                }
            }
            LedgerReq::Close(index) => {
                // Drop device handle
                if let Some(d) = self.devices.remove(index) {
                    debug!("Closed device {index}: {:?}", d.info());
                }

                // no response for close message (channel no longer exists)
                return None;
            }
        };

        Some(resp)
    }
}

================
File: lib/src/provider/mod.rs
================
//! [LedgerProvider] provides a tokio-based thread-safe interface for
//! interacting with ledger devices.

use std::time::Duration;

use tokio::sync::{
    mpsc::{unbounded_channel, UnboundedSender},
    OnceCell,
};

mod context;
use context::ProviderContext;

use crate::{error::Error, info::LedgerInfo, transport::Transport, Exchange, Filters};

/// Ledger provider manages device discovery and connection
pub struct LedgerProvider {
    req_tx: ReqChannel,
}

/// Ledger device handle for interacting with [LedgerProvider] backed devices
#[derive(Debug)]
pub struct LedgerHandle {
    pub info: LedgerInfo,

    /// Device index in provider map
    index: usize,

    /// Channel for issuing requests to the provider task
    req_tx: ReqChannel,
}

/// Request object for communication to the provider task
#[derive(Clone, Debug, PartialEq)]
pub enum LedgerReq {
    /// List available devices
    List(Filters),

    /// Connect to a specific device
    Connect(LedgerInfo),

    /// APDU request issued to a device handle
    Req(usize, Vec<u8>, Duration),

    /// Close the device handle
    Close(usize),
}

/// Request object for communication from the provider task
#[derive(Debug)]
pub enum LedgerResp {
    /// List of available ledger devices
    Devices(Vec<LedgerInfo>),

    /// Device handle following connection
    Handle(usize),

    /// APDU response from a device handle
    Resp(Vec<u8>),

    /// Error / operation failure
    Error(Error),
}

/// Helper type alias for [LedgerProvider] requests
pub type ReqChannel = UnboundedSender<(LedgerReq, UnboundedSender<LedgerResp>)>;

/// Global provider context, handle for pinned thread used for device communication
static PROVIDER_CTX: OnceCell<ProviderContext> = OnceCell::const_new();

impl LedgerProvider {
    /// Create or connect to the ledger provider instance
    pub async fn init() -> Self {
        // Fetch or create the provider context
        let ctx = PROVIDER_CTX
            .get_or_init(|| async { ProviderContext::new().await })
            .await;

        // Return handle to request channel
        Self {
            req_tx: ctx.req_tx(),
        }
    }
}

/// [Transport] implementation for high-level [LedgerProvider]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Transport for LedgerProvider {
    type Device = LedgerHandle;
    type Info = LedgerInfo;
    type Filters = Filters;

    /// List available devices using the specified filter
    async fn list(&mut self, filters: Filters) -> Result<Vec<LedgerInfo>, Error> {
        let (tx, mut rx) = unbounded_channel::<LedgerResp>();

        // Send control request
        self.req_tx
            .send((LedgerReq::List(filters), tx))
            .map_err(|_| Error::Unknown)?;

        // Await resposne
        match rx.recv().await {
            Some(LedgerResp::Devices(i)) => Ok(i),
            Some(LedgerResp::Error(e)) => Err(e),
            _ => Err(Error::Unknown),
        }
    }

    /// Connect to an available device
    async fn connect(&mut self, info: LedgerInfo) -> Result<LedgerHandle, Error> {
        let (tx, mut rx) = unbounded_channel::<LedgerResp>();

        // Send control request
        self.req_tx
            .send((LedgerReq::Connect(info.clone()), tx))
            .map_err(|_| Error::Unknown)?;

        // Await resposne
        match rx.recv().await {
            Some(LedgerResp::Handle(index)) => Ok(LedgerHandle {
                info,
                index,
                req_tx: self.req_tx.clone(),
            }),
            Some(LedgerResp::Error(e)) => Err(e),
            _ => Err(Error::Unknown),
        }
    }
}

/// [Exchange] implementation for [LedgerProvider] backed [LedgerHandle]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Exchange for LedgerHandle {
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        let (tx, mut rx) = unbounded_channel::<LedgerResp>();

        // Send APDU request
        self.req_tx
            .send((LedgerReq::Req(self.index, command.to_vec(), timeout), tx))
            .map_err(|_| Error::Unknown)?;

        // Await APDU response
        match rx.recv().await {
            Some(LedgerResp::Resp(data)) => Ok(data),
            Some(LedgerResp::Error(e)) => Err(e),
            _ => Err(Error::Unknown),
        }
    }
}

/// [Drop] impl sends close message to provider when [LedgerHandle] is dropped
impl Drop for LedgerHandle {
    fn drop(&mut self) {
        let (tx, _rx) = unbounded_channel::<LedgerResp>();
        let _ = self.req_tx.send((LedgerReq::Close(self.index), tx));
    }
}

================
File: lib/src/transport/ble.rs
================
//! Bluetooth Low Energy (BLE) transport

use std::{fmt::Display, pin::Pin, time::Duration};

use btleplug::{
    api::{
        BDAddr, Central as _, Characteristic, Manager as _, Peripheral, ScanFilter,
        ValueNotification, WriteType,
    },
    platform::Manager,
};
use futures::{stream::StreamExt, Stream};
use tracing::{debug, error, trace, warn};
use uuid::{uuid, Uuid};

use super::{Exchange, Transport};
use crate::{
    info::{ConnInfo, LedgerInfo, Model},
    Error,
};

/// Transport for listing and connecting to BLE connected Ledger devices
pub struct BleTransport {
    manager: Manager,
    peripherals: Vec<(LedgerInfo, btleplug::platform::Peripheral)>,
}

/// BLE specific device information
#[derive(Clone, Debug, PartialEq)]
pub struct BleInfo {
    name: String,
    addr: BDAddr,
}

impl Display for BleInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name)
    }
}

/// BLE connected ledger device
pub struct BleDevice {
    pub info: BleInfo,
    mtu: u8,
    p: btleplug::platform::Peripheral,
    c_write: Characteristic,
    c_read: Characteristic,
}

/// Bluetooth spec for ledger devices
/// see: https://github.com/LedgerHQ/ledger-live/blob/develop/libs/ledgerjs/packages/devices/src/index.ts#L32
#[derive(Clone, PartialEq, Debug)]
struct BleSpec {
    pub model: Model,
    pub service_uuid: Uuid,
    pub notify_uuid: Uuid,
    pub write_uuid: Uuid,
    pub write_cmd_uuid: Uuid,
}

/// Spec for types of bluetooth device
const BLE_SPECS: &[BleSpec] = &[
    BleSpec {
        model: Model::NanoX,
        service_uuid: uuid!("13d63400-2c97-0004-0000-4c6564676572"),
        notify_uuid: uuid!("13d63400-2c97-0004-0001-4c6564676572"),
        write_uuid: uuid!("13d63400-2c97-0004-0002-4c6564676572"),
        write_cmd_uuid: uuid!("13d63400-2c97-0004-0003-4c6564676572"),
    },
    BleSpec {
        model: Model::Stax,
        service_uuid: uuid!("13d63400-2c97-6004-0000-4c6564676572"),
        notify_uuid: uuid!("13d63400-2c97-6004-0001-4c6564676572"),
        write_uuid: uuid!("13d63400-2c97-6004-0002-4c6564676572"),
        write_cmd_uuid: uuid!("13d63400-2c97-6004-0003-4c6564676572"),
    },
];

impl BleTransport {
    pub async fn new() -> Result<Self, Error> {
        // Setup connection manager
        let manager = Manager::new().await?;

        Ok(Self {
            manager,
            peripherals: vec![],
        })
    }

    /// Helper to perform scan for available BLE devices, used in [list] and [connect].
    async fn scan_internal(
        &self,
        duration: Duration,
    ) -> Result<Vec<(LedgerInfo, btleplug::platform::Peripheral)>, Error> {
        let mut matched = vec![];

        // Grab adapter list
        let adapters = self.manager.adapters().await?;

        // TODO: load filters?
        let f = ScanFilter { services: vec![] };

        // Search using adapters
        for adapter in adapters.iter() {
            let info = adapter.adapter_info().await?;
            debug!("Scan with adapter {info}");

            // Start scan with adaptor
            adapter.start_scan(f.clone()).await?;

            tokio::time::sleep(duration).await;

            // Fetch peripheral list
            let mut peripherals = adapter.peripherals().await?;
            if peripherals.is_empty() {
                debug!("No peripherals found on adaptor {info}");
                continue;
            }

            // Load peripheral information
            for p in peripherals.drain(..) {
                // Fetch peripheral properties
                let (properties, _connected) = (p.properties().await?, p.is_connected().await?);

                // Skip peripherals where we couldn't fetch properties
                let properties = match properties {
                    Some(v) => v,
                    None => {
                        debug!("Failed to fetch properties for peripheral: {p:?}");
                        continue;
                    }
                };

                // Skip peripherals without a local name (NanoX should report this)
                let name = match &properties.local_name {
                    Some(v) => v,
                    None => continue,
                };

                debug!("Peripheral: {p:?} props: {properties:?}");

                // Match on peripheral names
                let model = if name.contains("Nano X") {
                    Model::NanoX
                } else if name.contains("Stax") {
                    Model::Stax
                } else {
                    continue;
                };

                // Add to device list
                matched.push((
                    LedgerInfo {
                        model: model.clone(),
                        conn: BleInfo {
                            name: name.clone(),
                            addr: properties.address,
                        }
                        .into(),
                    },
                    p,
                ));
            }
        }

        Ok(matched)
    }
}

/// [Transport] implementation for [BleTransport]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Transport for BleTransport {
    type Filters = ();
    type Info = BleInfo;
    type Device = BleDevice;

    /// List BLE connected ledger devices
    async fn list(&mut self, _filters: Self::Filters) -> Result<Vec<LedgerInfo>, Error> {
        // Scan for available devices
        let devices = self.scan_internal(Duration::from_millis(1000)).await?;

        // Filter to return info list
        let info: Vec<_> = devices.iter().map(|d| d.0.clone()).collect();

        // Save listed devices for next connect
        self.peripherals = devices;

        Ok(info)
    }

    /// Connect to a specific ledger device
    ///
    /// Note: this _must_ follow a [Self::list] operation to match `info` with known peripherals
    async fn connect(&mut self, info: Self::Info) -> Result<Self::Device, Error> {
        // Match known peripherals using provided device info
        let (d, p) = match self
            .peripherals
            .iter()
            .find(|(d, _p)| d.conn == info.clone().into())
        {
            Some(v) => v,
            None => {
                warn!("No device found matching: {info:?}");
                return Err(Error::NoDevices);
            }
        };
        let i = match &d.conn {
            ConnInfo::Ble(i) => i,
            _ => unreachable!(),
        };

        let name = &i.name;

        // Fetch properties
        let properties = p.properties().await?;

        // Connect to device and subscribe to characteristics
        // Fetch specs for matched model (contains characteristic identifiers)
        let specs = match BLE_SPECS.iter().find(|s| s.model == d.model) {
            Some(v) => v,
            None => {
                warn!("No specs for model: {:?}", d.model);
                return Err(Error::Unknown);
            }
        };

        // If we're not connected, attempt to connect
        if !p.is_connected().await? {
            if let Err(e) = p.connect().await {
                warn!("Failed to connect to {name}: {e:?}");
                return Err(Error::Unknown);
            }

            if !p.is_connected().await? {
                warn!("Not connected to {name}");
                return Err(Error::Unknown);
            }
        }

        debug!("peripheral {name}: {p:?} properties: {properties:?}");

        // Then, grab available services and locate characteristics
        p.discover_services().await?;

        let characteristics = p.characteristics();

        trace!("Characteristics: {characteristics:?}");

        let c_write = characteristics.iter().find(|c| c.uuid == specs.write_uuid);
        let c_read = characteristics.iter().find(|c| c.uuid == specs.notify_uuid);

        let (c_write, c_read) = match (c_write, c_read) {
            (Some(w), Some(r)) => (w, r),
            _ => {
                error!("Failed to match read and write characteristics for {name}");
                return Err(Error::Unknown);
            }
        };

        // Create device instance
        let mut d = BleDevice {
            info: info.clone(),
            mtu: 23,
            p: p.clone(),
            c_write: c_write.clone(),
            c_read: c_read.clone(),
        };

        // Request MTU (cmd 0x08, seq: 0x0000, len: 0x0000)
        match d.fetch_mtu().await {
            Ok(mtu) => d.mtu = mtu,
            Err(e) => {
                warn!("Failed to fetch MTU: {:?}", e);
            }
        }

        debug!("using MTU: {}", d.mtu);

        Ok(d)
    }
}

const BLE_HEADER_LEN: usize = 3;

impl BleDevice {
    /// Helper to write commands as chunks based on device MTU
    async fn write_command(&mut self, cmd: u8, payload: &[u8]) -> Result<(), Error> {
        // Setup outgoing data (adds 2-byte big endian length prefix)
        let mut data = Vec::with_capacity(payload.len() + 2);
        data.extend_from_slice(&(payload.len() as u16).to_be_bytes()); // Data length
        data.extend_from_slice(payload); // Data

        debug!("TX cmd: 0x{cmd:02x} payload: {data:02x?}");

        // Write APDU in chunks
        for (i, c) in data.chunks(self.mtu as usize - BLE_HEADER_LEN).enumerate() {
            // Setup chunk buffer
            let mut buff = Vec::with_capacity(self.mtu as usize);
            let cmd = match i == 0 {
                true => cmd,
                false => 0x03,
            };

            buff.push(cmd); // Command
            buff.extend_from_slice(&(i as u16).to_be_bytes()); // Sequence ID
            buff.extend_from_slice(c);

            debug!("Write chunk {i}: {:02x?}", buff);

            self.p
                .write(&self.c_write, &buff, WriteType::WithResponse)
                .await?;
        }

        Ok(())
    }

    /// Helper to read response packet from notification channel
    async fn read_data(
        &mut self,
        mut notifications: Pin<Box<dyn Stream<Item = ValueNotification> + Send>>,
    ) -> Result<Vec<u8>, Error> {
        // Await first response
        let v = match notifications.next().await {
            Some(v) => v.value,
            None => {
                return Err(Error::Closed);
            }
        };

        debug!("RX: {:02x?}", v);

        // Check response length is reasonable
        if v.len() < 5 {
            error!("response too short");
            return Err(Error::UnexpectedResponse);
        } else if v[0] != 0x05 {
            error!("unexpected response type: {:?}", v[0]);
            return Err(Error::UnexpectedResponse);
        }

        // Read out full response length
        let len = v[4] as usize;
        if len == 0 {
            return Err(Error::EmptyResponse);
        }

        trace!("Expecting response length: {}", len);

        // Setup response buffer
        let mut buff = Vec::with_capacity(len);
        buff.extend_from_slice(&v[5..]);

        // Read further responses
        // TODO: check this is correct with larger packets
        while buff.len() < len {
            // Await response notification
            let v = match notifications.next().await {
                Some(v) => v.value,
                None => {
                    error!("Failed to fetch next chunk from peripheral");
                    self.p.unsubscribe(&self.c_read).await?;
                    return Err(Error::Closed);
                }
            };

            debug!("RX: {v:02x?}");

            // TODO: check sequence index?

            // add received data to buffer
            buff.extend_from_slice(&v[5..]);
        }

        Ok(buff)
    }

    /// Helper to fetch the available MTU from a bluetooth device
    async fn fetch_mtu(&mut self) -> Result<u8, Error> {
        // Setup read characteristic subscription
        self.p.subscribe(&self.c_read).await?;
        let mut n = self.p.notifications().await?;

        // Write get mtu command
        self.write_command(0x08, &[]).await?;

        // Await MTU response
        let mtu = match n.next().await {
            Some(r) if r.value[0] == 0x08 && r.value.len() == 6 => {
                debug!("RX: {:02x?}", r);
                r.value[5]
            }
            Some(r) => {
                warn!("Unexpected MTU response: {r:02x?}");
                return Err(Error::Unknown);
            }
            None => {
                warn!("Failed to request MTU");
                return Err(Error::Unknown);
            }
        };

        // Unsubscribe from characteristic
        self.p.unsubscribe(&self.c_read).await?;

        Ok(mtu)
    }

    pub(crate) async fn is_connected(&self) -> Result<bool, Error> {
        let c = self.p.is_connected().await?;
        Ok(c)
    }
}

/// [Exchange] impl for BLE backed devices
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Exchange for BleDevice {
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        // Fetch notification channel for responses
        self.p.subscribe(&self.c_read).await?;
        let notifications = self.p.notifications().await?;

        // Write command data
        if let Err(e) = self.write_command(0x05, command).await {
            self.p.unsubscribe(&self.c_read).await?;
            return Err(e);
        }

        debug!("Await response");

        // Wait for response
        let buff = match tokio::time::timeout(timeout, self.read_data(notifications)).await {
            Ok(Ok(v)) => v,
            Ok(Err(e)) => {
                self.p.unsubscribe(&self.c_read).await?;
                return Err(e);
            }
            Err(e) => {
                self.p.unsubscribe(&self.c_read).await?;
                return Err(e.into());
            }
        };

        Ok(buff)
    }
}

================
File: lib/src/transport/mod.rs
================
//! Low-level transport implementations for communication with ledger devices and nano apps
//!
//! Transports are gated by `transport_X` features, while [GenericTransport] and
//! [GenericDevice] provide an abstraction over enabled transports.
//!
//! # Safety
//! [UsbTransport] (and thus [GenericTransport] when `transport_usb` feature is enabled)
//! is _not_ `Send` or `Sync`, however this is marked as such to appease `async_trait`...
//!
//! Once `async_trait` has stabilised transports can be marked correctly.
//! (This is also implemented under the `unstable_async_trait` feature)
//! Until then, use [LedgerProvider](crate::LedgerProvider) for a `Sync + Send` interface or
//!  be _super sure_ you're not going to call transports from a multi-threaded context.

use std::{fmt::Debug, time::Duration};

#[cfg(feature = "transport_ble")]
use tracing::warn;

use tracing::debug;

#[cfg(feature = "transport_usb")]
mod usb;
#[cfg(feature = "transport_usb")]
pub use usb::{UsbDevice, UsbInfo, UsbTransport};

#[cfg(feature = "transport_ble")]
mod ble;
#[cfg(feature = "transport_ble")]
pub use ble::{BleDevice, BleInfo, BleTransport};

#[cfg(feature = "transport_tcp")]
mod tcp;
#[cfg(feature = "transport_tcp")]
pub use tcp::{TcpDevice, TcpInfo, TcpTransport};

use crate::{
    info::{ConnInfo, LedgerInfo},
    Error, Exchange, Filters,
};

/// [Transport] trait provides an abstract interface for transport implementations
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
pub trait Transport {
    /// Connection filters
    type Filters: Default + Debug;
    /// Device information, used for listing and connecting
    type Info: Debug;
    /// Device handle for interacting with the device
    type Device: Exchange;

    /// List available devices
    async fn list(&mut self, filters: Self::Filters) -> Result<Vec<LedgerInfo>, Error>;

    /// Connect to a device using info from a previous list operation
    async fn connect(&mut self, info: Self::Info) -> Result<Self::Device, Error>;
}

/// Blanket [Transport] implementation for references types
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl<T: Transport + Send> Transport for &mut T
where
    <T as Transport>::Device: Send,
    <T as Transport>::Filters: Send,
    <T as Transport>::Info: Send,
{
    type Filters = <T as Transport>::Filters;
    type Info = <T as Transport>::Info;
    type Device = <T as Transport>::Device;

    async fn list(&mut self, filters: Self::Filters) -> Result<Vec<LedgerInfo>, Error> {
        <T as Transport>::list(self, filters).await
    }
    async fn connect(&mut self, info: Self::Info) -> Result<Self::Device, Error> {
        <T as Transport>::connect(self, info).await
    }
}

/// [GenericTransport] for device communication, abstracts underlying transport types
///
pub struct GenericTransport {
    #[cfg(feature = "transport_usb")]
    usb: UsbTransport,

    #[cfg(feature = "transport_ble")]
    ble: BleTransport,

    #[cfg(feature = "transport_tcp")]
    tcp: TcpTransport,
}

/// [GenericDevice] for communication with ledger devices, abstracts underlying transport types
///
pub enum GenericDevice {
    #[cfg(feature = "transport_usb")]
    Usb(UsbDevice),

    #[cfg(feature = "transport_ble")]
    Ble(BleDevice),

    #[cfg(feature = "transport_tcp")]
    Tcp(TcpDevice),
}

impl GenericTransport {
    /// Create a new [GenericTransport] with all endabled transports
    pub async fn new() -> Result<Self, Error> {
        debug!("Initialising GenericTransport");

        Ok(Self {
            #[cfg(feature = "transport_usb")]
            usb: UsbTransport::new()?,

            #[cfg(feature = "transport_ble")]
            ble: BleTransport::new().await?,

            #[cfg(feature = "transport_tcp")]
            tcp: TcpTransport::new()?,
        })
    }
}

#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Transport for GenericTransport {
    type Filters = Filters;
    type Info = LedgerInfo;
    type Device = GenericDevice;

    /// List available ledger devices using all enabled transports
    async fn list(&mut self, filters: Filters) -> Result<Vec<LedgerInfo>, Error> {
        let mut devices = vec![];

        #[cfg(feature = "transport_usb")]
        if filters == Filters::Any || filters == Filters::Hid {
            let mut d = self.usb.list(()).await?;
            devices.append(&mut d);
        }

        #[cfg(feature = "transport_ble")]
        if filters == Filters::Any || filters == Filters::Ble {
            // BLE discovery is allowed to fail if not exclusively selected
            // as dbus does not always provide the relevant service (eg. under WSL)
            // TODO: work out whether we can detect this to separate no BLE from discovery failure
            match self.ble.list(()).await {
                Ok(mut d) => devices.append(&mut d),
                Err(e) if filters == Filters::Any => {
                    warn!("BLE discovery failed: {e:?}");
                }
                Err(e) => return Err(e),
            }
        }

        #[cfg(feature = "transport_tcp")]
        if filters == Filters::Any || filters == Filters::Tcp {
            let mut d = self.tcp.list(()).await?;
            devices.append(&mut d);
        }

        Ok(devices)
    }

    /// Connect to a ledger device using available transports
    ///
    async fn connect(&mut self, info: LedgerInfo) -> Result<GenericDevice, Error> {
        debug!("Connecting to device: {:?}", info);

        let d = match info.conn {
            #[cfg(feature = "transport_usb")]
            ConnInfo::Usb(i) => self.usb.connect(i).await.map(GenericDevice::Usb)?,
            #[cfg(feature = "transport_tcp")]
            ConnInfo::Tcp(i) => self.tcp.connect(i).await.map(GenericDevice::Tcp)?,
            #[cfg(feature = "transport_ble")]
            ConnInfo::Ble(i) => self.ble.connect(i).await.map(GenericDevice::Ble)?,
        };

        Ok(d)
    }
}

impl GenericDevice {
    /// Fetch connection info for a device
    pub fn info(&self) -> ConnInfo {
        match self {
            #[cfg(feature = "transport_usb")]
            GenericDevice::Usb(d) => d.info.clone().into(),
            #[cfg(feature = "transport_ble")]
            GenericDevice::Ble(d) => d.info.clone().into(),
            #[cfg(feature = "transport_tcp")]
            GenericDevice::Tcp(d) => d.info.clone().into(),
        }
    }

    pub(crate) async fn is_connected(&self) -> Result<bool, Error> {
        match self {
            #[cfg(feature = "transport_usb")]
            GenericDevice::Usb(d) => d.is_connected().await,
            #[cfg(feature = "transport_ble")]
            GenericDevice::Ble(d) => d.is_connected().await,
            #[cfg(feature = "transport_tcp")]
            GenericDevice::Tcp(d) => d.is_connected().await,
        }
    }
}

#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Exchange for GenericDevice {
    /// Exchange an APDU with the [GenericDevice]
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        match self {
            #[cfg(feature = "transport_usb")]
            Self::Usb(d) => d.exchange(command, timeout).await,
            #[cfg(feature = "transport_ble")]
            Self::Ble(d) => d.exchange(command, timeout).await,
            #[cfg(feature = "transport_tcp")]
            Self::Tcp(d) => d.exchange(command, timeout).await,
        }
    }
}

#[cfg(feature = "transport_usb")]
impl From<UsbDevice> for GenericDevice {
    fn from(value: UsbDevice) -> Self {
        Self::Usb(value)
    }
}

#[cfg(feature = "transport_tcp")]
impl From<TcpDevice> for GenericDevice {
    fn from(value: TcpDevice) -> Self {
        Self::Tcp(value)
    }
}

#[cfg(feature = "transport_ble")]
impl From<BleDevice> for GenericDevice {
    fn from(value: BleDevice) -> Self {
        Self::Ble(value)
    }
}

================
File: lib/src/transport/tcp.rs
================
use std::{
    fmt::Display,
    net::{Ipv4Addr, SocketAddr, SocketAddrV4},
    time::Duration,
};

use tokio::{
    io::{AsyncReadExt, AsyncWriteExt, Interest},
    net::{TcpListener, TcpStream},
};
use tracing::{debug, error};

use crate::{
    info::{LedgerInfo, Model},
    Error,
};

use super::{Exchange, Transport};

/// TCP transport implementation for interacting with Speculos via the TCP APDU socket
#[derive(Default)]
pub struct TcpTransport {}

/// TCP based device
pub struct TcpDevice {
    s: TcpStream,
    pub info: TcpInfo,
}

/// TCP device information
#[derive(Clone, PartialEq, Debug)]
pub struct TcpInfo {
    pub addr: SocketAddr,
}

impl Default for TcpInfo {
    fn default() -> Self {
        Self {
            addr: SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 1237)),
        }
    }
}

impl Display for TcpInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.addr)
    }
}

impl TcpTransport {
    /// Create a new [TcpTransport] instance
    pub fn new() -> Result<Self, Error> {
        Ok(Self {})
    }
}

#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Transport for TcpTransport {
    type Filters = ();
    type Info = TcpInfo;
    type Device = TcpDevice;

    /// List available devices using the [TcpTransport]
    ///
    /// (This looks for a speculos socket on the default port and returns a device if found,
    /// if you want to connect to a specific device use [TcpTransport::connect])
    async fn list(&mut self, _filters: Self::Filters) -> Result<Vec<LedgerInfo>, Error> {
        let mut devices = vec![];

        // Check whether a speculos socket is open on the default port
        let addr = SocketAddr::new(Ipv4Addr::new(0, 0, 0, 0).into(), 1237);

        // We can't -connect- to speculos as this does not handle multiple TCP connections
        // so instead we attempt to bind to the socket we expect speculos to occupy.
        match TcpListener::bind(addr).await {
            Ok(_) => (),
            // A failure indicates this is in use and we should report a device available for connection
            Err(_) => {
                devices.push(LedgerInfo {
                    conn: TcpInfo { addr }.into(),
                    model: Model::Unknown(0),
                });
            }
        }

        Ok(devices)
    }

    /// Connect to a TCP device using the provided [TcpInfo]
    async fn connect(&mut self, info: TcpInfo) -> Result<TcpDevice, Error> {
        debug!("Connecting to: {:?}", info);

        // Connect to provided TCP socket
        let s = match TcpStream::connect(info.addr).await {
            Ok(v) => v,
            Err(e) => {
                error!("TCP connection failed: {:?}", e);
                return Err(e.into());
            }
        };

        // Return TCP device handle
        Ok(TcpDevice { s, info })
    }
}

impl TcpDevice {
    /// Internal helper to write command data
    async fn write_command(&mut self, req: &[u8]) -> Result<(), Error> {
        // Setup data buffer to send
        let mut buff = vec![0; 4 + req.len()];

        // Write APDU length
        buff[0..4].copy_from_slice(&(req.len() as u32).to_be_bytes());

        // Write APDU data
        buff[4..].copy_from_slice(req);

        debug!("TX: {:02x?}", buff);

        // Send APDU request
        if let Err(e) = self.s.write_all(&buff).await {
            error!("Failed to write request APDU: {:?}", e);
            return Err(e.into());
        }

        Ok(())
    }

    /// Internal helper to read response data
    async fn read_data(&mut self) -> Result<Vec<u8>, Error> {
        let mut buff = vec![0u8; 4];

        // Read response length (u32 big endian + 2 bytes for status)
        let n = match self.s.read_exact(&mut buff[..4]).await {
            Ok(_) => u32::from_be_bytes(buff[..4].try_into().unwrap()) as usize + 2,
            Err(e) => {
                error!("Failed to read response APDU length: {:?}", e);
                return Err(e.into());
            }
        };

        // Read response data
        buff.resize(n + 4, 0);
        if let Err(e) = self.s.read_exact(&mut buff[4..][..n]).await {
            error!("Failed to read response APDU data: {:?}", e);
            return Err(e.into());
        }

        debug!("RX: {:02x?}", buff);

        // Return response data
        Ok(buff[4..].to_vec())
    }

    pub(crate) async fn is_connected(&self) -> Result<bool, Error> {
        let r = self.s.ready(Interest::WRITABLE).await?;
        Ok(!r.is_read_closed() || !r.is_write_closed())
    }
}

/// [Exchange] implementation for the TCP transport
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Exchange for TcpDevice {
    async fn exchange(&mut self, req: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        // Write APDU request
        self.write_command(req).await?;

        // Await APDU response with timeout
        let d = match tokio::time::timeout(timeout, self.read_data()).await {
            Ok(Ok(d)) => d,
            Ok(Err(e)) => return Err(e),
            Err(e) => return Err(e.into()),
        };

        // Return response data
        Ok(d)
    }
}

================
File: lib/src/transport/usb.rs
================
//! USB HID transport implementation
//!
//! # SAFETY
//!
//! This is _not_ `Send` or thread safe, see [transport][crate::transport] docs for
//! more details.
//!

use std::{ffi::CString, fmt::Display, io::ErrorKind, time::Duration};

use hidapi::{HidApi, HidDevice, HidError};
use tracing::{debug, error, trace, warn};

use crate::{
    info::{LedgerInfo, Model},
    Error,
};

use super::{Exchange, Transport};

/// Basic USB device information
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "clap", derive(clap::Parser))]
pub struct UsbInfo {
    #[cfg_attr(feature = "clap", clap(long, value_parser=u16_parse_hex))]
    /// USB Device Vendor ID (VID) in hex
    pub vid: u16,

    #[cfg_attr(feature = "clap", clap(long, value_parser=u16_parse_hex))]
    /// USB Device Product ID (PID) in hex
    pub pid: u16,

    #[cfg_attr(feature = "clap", clap(long))]
    /// Device path
    pub path: Option<String>,
}

impl Display for UsbInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:04x}:{:04x}", self.vid, self.pid)
    }
}

/// Helper to pass VID/PID pairs from hex values
#[cfg(feature = "clap")]
fn u16_parse_hex(s: &str) -> Result<u16, std::num::ParseIntError> {
    u16::from_str_radix(s, 16)
}

/// USB HID based transport
///
/// # Safety
/// Due to `hidapi` this is not thread safe an only one instance must exist in an application.
/// If you don't need low-level control see [crate::LedgerProvider] for a tokio based wrapper.
pub struct UsbTransport {
    hid_api: HidApi,
}

/// USB HID based device
pub struct UsbDevice {
    pub info: UsbInfo,
    device: HidDevice,
}

/// Ledger USB VID
pub const LEDGER_VID: u16 = 0x2c97;

impl UsbTransport {
    /// Create a new [UsbTransport]
    pub fn new() -> Result<Self, Error> {
        Ok(Self {
            hid_api: HidApi::new()?,
        })
    }
}

// With the unstable_async_trait feature we can (correctly) mark this as non-send
// however [async_trait] can't easily differentiate between send and non-send so we're
// exposing this as Send for the moment

#[cfg(feature = "unstable_async_trait")]
impl !Send for UsbDevice {}
#[cfg(feature = "unstable_async_trait")]
impl !Sync for UsbDevice {}

#[cfg(feature = "unstable_async_trait")]
impl !Send for UsbTransport {}
#[cfg(feature = "unstable_async_trait")]
impl !Sync for UsbTransport {}

/// WARNING: THIS IS A LIE TO APPEASE `async_trait`
#[cfg(not(feature = "unstable_async_trait"))]
unsafe impl Send for UsbTransport {}

#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Transport for UsbTransport {
    type Filters = ();
    type Info = UsbInfo;
    type Device = UsbDevice;

    /// List available devices using the [UsbTransport]
    async fn list(&mut self, _filters: Self::Filters) -> Result<Vec<LedgerInfo>, Error> {
        debug!("Listing USB devices");

        // Refresh available devices
        // TODO: determine whether the refresh call is critical (or, useful?)
        if let Err(e) = self.hid_api.refresh_devices() {
            warn!("Failed to refresh devices: {e:?}");
        }

        tokio::time::sleep(Duration::from_millis(200)).await;

        // Fetch list of devices, filtering for ledgers
        let devices: Vec<_> = self
            .hid_api
            .device_list()
            .filter(|d| d.vendor_id() == LEDGER_VID)
            .map(|d| LedgerInfo {
                model: Model::from_pid(d.product_id()),
                conn: UsbInfo {
                    vid: d.vendor_id(),
                    pid: d.product_id(),
                    path: Some(d.path().to_string_lossy().to_string()),
                }
                .into(),
            })
            .collect();

        debug!("devices: {:?}", devices);

        Ok(devices)
    }

    /// Connect to a device using the usb transport
    async fn connect(&mut self, info: UsbInfo) -> Result<UsbDevice, Error> {
        debug!("Connecting to USB device: {:?}", info);

        // If we have a path, use this to connect
        let d = if let Some(p) = &info.path {
            let p = CString::new(p.clone()).unwrap();
            self.hid_api.open_path(&p)

        // Otherwise, fallback to (non unique!) vid:pid
        } else {
            self.hid_api.open(info.vid, info.pid)
        };

        match d {
            Ok(d) => {
                debug!("Connected to USB device: {:?}", info);
                Ok(UsbDevice { device: d, info })
            }
            Err(e) => {
                debug!("Failed to connect to USB device: {:?}", e);
                Err(e.into())
            }
        }
    }
}

// HID packet length (header + data)
const HID_PACKET_LEN: usize = 64;

// Five bytes: channnel (0x101), tag (0x05), sequence index
const HID_HEADER_LEN: usize = 5;

impl UsbDevice {
    /// Write an APDU to the device
    pub fn write(&mut self, apdu: &[u8]) -> Result<(), Error> {
        debug!("Write APDU");

        // Setup outgoing data buffer with length prefix
        let mut data = Vec::with_capacity(apdu.len() + 2);
        data.extend_from_slice(&(apdu.len() as u16).to_be_bytes());
        data.extend_from_slice(apdu);

        debug!("TX: {:02x?}", data);

        // Write data in 64 byte chunks
        for (i, c) in data.chunks(HID_PACKET_LEN - HID_HEADER_LEN).enumerate() {
            trace!("Writing chunk {} of {} bytes", i, c.len());

            // Setup HID packet with header and data
            let mut packet = Vec::with_capacity(HID_PACKET_LEN + 1);

            // Zero prefix for unknown reasons
            packet.push(0x00);

            // Header channnel (0x101), tag (0x05), sequence index
            packet.extend_from_slice(&[0x01, 0x01, 0x05]);
            packet.extend_from_slice(&(i as u16).to_be_bytes());
            // Remaining data
            packet.extend_from_slice(c);

            trace!("Write: 0x{:02x?}", packet);

            // Write HID packet
            self.device.write(&packet)?;
        }

        Ok(())
    }

    /// Read an APDU from the device
    pub fn read(&mut self, timeout: Duration) -> Result<Vec<u8>, Error> {
        debug!("Read APDU");

        let mut buff = [0u8; HID_PACKET_LEN + 1];

        // Read first chunk of response
        // Timeout argument applied here as once the reply has started timeout bounds should be more consistent
        let n = match self
            .device
            .read_timeout(&mut buff, timeout.as_millis() as i32)
        {
            Ok(n) => n,
            Err(HidError::IoError { error }) if error.kind() == ErrorKind::TimedOut => {
                return Err(Error::Timeout)
            }
            Err(e) => return Err(e.into()),
        };

        // Check read length is valid for following operations
        if n == 0 {
            error!("Empty response");
            return Err(Error::EmptyResponse);
        } else if n < 7 {
            error!("Unexpected read length {n}");
            return Err(Error::UnexpectedResponse);
        }

        // Check header matches expectations
        if buff[..5] != [0x01, 0x01, 0x05, 0x00, 0x00] {
            error!("Unexpected response header: {:02x?}", &buff[..5]);
            return Err(Error::UnexpectedResponse);
        }

        trace!("initial read: {buff:02x?}");

        // Parse response length
        let len = u16::from_be_bytes([buff[5], buff[6]]) as usize;

        trace!("Read len: {len}");

        // Setup response buffer and add any remaining data
        let mut resp = Vec::with_capacity(len);

        let data_len = len.min(n - 7);
        resp.extend_from_slice(&buff[7..][..data_len]);

        // Read following chunks if required
        let mut seq_idx = 1;
        while resp.len() < len {
            let rem = len - resp.len();

            trace!("Read chunk {seq_idx} ({rem} bytes remaining)");

            // Read next chunk, constant timeout as chunks should be sent end-to-end
            let n = match self.device.read_timeout(&mut buff, 500) {
                Ok(n) => n,
                Err(e) => return Err(e.into()),
            };

            if n < 5 {
                error!("Invalid chunk length {n}");
                return Err(Error::UnexpectedResponse);
            }

            // Check header and sequence index
            if buff[..3] != [0x01, 0x01, 0x05] {
                error!("Unexpected response header: {:02x?}", &buff[..5]);
                return Err(Error::UnexpectedResponse);
            }
            if u16::from_be_bytes([buff[3], buff[4]]) != seq_idx {
                error!("Unexpected sequence index: {:02x?}", &buff[5..7]);
                return Err(Error::UnexpectedResponse);
            }

            // Add to response buffer
            let data_len = rem.min(n - 5);
            resp.extend_from_slice(&buff[5..][..data_len]);
            seq_idx += 1;
        }

        debug!("RX: {:02x?}", resp);

        Ok(resp)
    }

    pub(crate) async fn is_connected(&self) -> Result<bool, Error> {
        Ok(self.device.get_device_info().is_ok())
    }
}

/// [Exchange] impl for sending APDUs to a [UsbDevice]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl Exchange for UsbDevice {
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        // Write APDU command, chunked for HID transport
        self.write(command)?;
        // Read APDU response, chunked for HID transport
        self.read(timeout)
    }
}

================
File: lib/src/device.rs
================
//! High-level Ledger [Device] abstraction for application development

use std::time::Duration;

use encdec::{EncDec, Encode};
use tracing::{debug, error};

use ledger_proto::{
    apdus::{AppInfoReq, AppInfoResp, DeviceInfoReq, DeviceInfoResp},
    ApduError, ApduReq, StatusCode,
};

use crate::{
    info::{AppInfo, DeviceInfo},
    Error, Exchange,
};

const APDU_BUFF_LEN: usize = 256;

/// [Device] provides a high-level interface exchanging APDU objects with implementers of [Exchange]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
pub trait Device {
    /// Issue a request APDU, returning a reponse APDU
    async fn request<'a, 'b, RESP: EncDec<'b, ApduError>>(
        &mut self,
        request: impl ApduReq<'a> + Send,
        buff: &'b mut [u8],
        timeout: Duration,
    ) -> Result<RESP, Error>;

    /// Fetch application information
    async fn app_info(&mut self, timeout: Duration) -> Result<AppInfo, Error> {
        let mut buff = [0u8; APDU_BUFF_LEN];

        let r = self
            .request::<AppInfoResp>(AppInfoReq {}, &mut buff[..], timeout)
            .await?;

        Ok(AppInfo {
            name: r.name.to_string(),
            version: r.version.to_string(),
            flags: r.flags,
        })
    }

    /// Fetch device information
    async fn device_info(&mut self, timeout: Duration) -> Result<DeviceInfo, Error> {
        let mut buff = [0u8; APDU_BUFF_LEN];

        let r = self
            .request::<DeviceInfoResp>(DeviceInfoReq {}, &mut buff[..], timeout)
            .await?;

        Ok(DeviceInfo {
            target_id: r.target_id,
            se_version: r.se_version.to_string(),
            mcu_version: r.mcu_version.to_string(),
            flags: r.flags.to_vec(),
        })
    }
}

/// Generic [Device] implementation for types supporting [Exchange]
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl<T: Exchange + Send> Device for T {
    /// Issue a request APDU to a device, encoding and decoding internally then returning a response APDU
    async fn request<'a, 'b, RESP: EncDec<'b, ApduError>>(
        &mut self,
        req: impl ApduReq<'a> + Send,
        buff: &'b mut [u8],
        timeout: Duration,
    ) -> Result<RESP, Error> {
        debug!("TX: {req:?}");

        // Encode request
        let n = encode_request(req, buff)?;

        // Send request to device
        let resp_bytes = self.exchange(&buff[..n], timeout).await?;

        // Copy response back to buffer prior to decode
        // (these hijinks are required to allow devices to avoid ownership of APDU data)
        let n = resp_bytes.len();
        if n > buff.len() {
            error!(
                "Response length exceeds buffer length ({} > {})",
                n,
                buff.len()
            );
            return Err(ApduError::InvalidLength.into());
        }
        buff[..n].copy_from_slice(&resp_bytes[..]);

        // Handle error responses (2 bytes long, only a status)
        if n == 2 {
            // Return status code if matched, unknown otherwise
            let v = u16::from_be_bytes([resp_bytes[0], resp_bytes[1]]);
            match StatusCode::try_from(v) {
                Ok(c) => return Err(Error::Status(c)),
                Err(_) => return Err(Error::UnknownStatus(resp_bytes[0], resp_bytes[1])),
            }
        }

        // Decode response data - status bytes
        let (resp, _) = RESP::decode(&buff[..n - 2])?;

        debug!("RX: {resp:?}");

        // Return decode response
        Ok(resp)
    }
}

/// Helper to perform APDU request encoding including the header, length, and body
fn encode_request<'a, REQ: ApduReq<'a>>(req: REQ, buff: &mut [u8]) -> Result<usize, Error> {
    let mut index = 0;

    let data_len = req.encode_len()?;

    // Check buffer length is reasonable
    if buff.len() < 5 + data_len {
        return Err(ApduError::InvalidLength.into());
    }

    // Encode request object

    // First the header
    let h = req.header();
    index += h.encode(&mut buff[index..])?;

    // Then the data length
    if data_len > u8::MAX as usize {
        return Err(ApduError::InvalidLength.into());
    }
    buff[index] = data_len as u8;
    index += 1;

    // Then finally the data
    index += req.encode(&mut buff[index..])?;

    Ok(index)
}

#[cfg(test)]
mod tests {
    use ledger_proto::{apdus::AppInfoReq, ApduStatic};

    use super::encode_request;

    #[test]
    fn test_encode_requests() {
        let mut buff = [0u8; 256];

        let req = AppInfoReq {};
        let n = encode_request(req, &mut buff).unwrap();
        assert_eq!(n, 5);
        assert_eq!(
            &buff[..n],
            &[AppInfoReq::CLA, AppInfoReq::INS, 0x00, 0x00, 0x00]
        );
    }
}

================
File: lib/src/error.rs
================
//! Ledger interface [Error] type and conversions

use ledger_proto::{ApduError, StatusCode};

/// Ledger interface error type
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[cfg(feature = "transport_usb")]
    #[error(transparent)]
    Hid(#[from] hidapi::HidError),

    #[cfg(feature = "transport_tcp")]
    #[error(transparent)]
    Tcp(#[from] tokio::io::Error),

    #[cfg(feature = "transport_ble")]
    #[error(transparent)]
    Ble(#[from] btleplug::Error),

    #[error("Unknown ledger model: {0}")]
    UnknownModel(u16),

    #[error("Unknown error")]
    Unknown,

    #[error("No devices found")]
    NoDevices,

    #[error("Invalid device index: {0}")]
    InvalidDeviceIndex(usize),

    #[error("Apdu encode/decode error: {0}")]
    Apdu(#[from] ApduError),

    /// Recognised status codes (see [StatusCode])
    #[error("Status: {0}")]
    Status(StatusCode),

    /// Unrecognised status codes
    #[error("Status: 0x{0:02x}{1:02x} (unrecognised)")]
    UnknownStatus(u8, u8),

    #[error("Request timeout")]
    Timeout,

    #[error("Device or transport closed")]
    Closed,

    #[error("Empty response payload")]
    EmptyResponse,

    #[error("Unexpected response payload")]
    UnexpectedResponse,

    #[error("Device in use")]
    DeviceInUse,

    #[error("Already running application ({0})")]
    ApplicationLoaded(String),
}

impl From<tokio::time::error::Elapsed> for Error {
    fn from(_e: tokio::time::error::Elapsed) -> Self {
        Self::Timeout
    }
}

================
File: lib/src/info.rs
================
//! Device information types and connection filters

use strum::{Display, EnumString};

use crate::Filters;

use super::transport;

/// Ledger device information
#[derive(Clone, PartialEq, Debug)]
pub struct LedgerInfo {
    /// Device Model
    pub model: Model,

    /// Device connection information
    pub conn: ConnInfo,
}

impl std::fmt::Display for LedgerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} ({})", self.model, self.conn)
    }
}

impl LedgerInfo {
    /// Fetch connection kind enumeration
    pub fn kind(&self) -> ConnType {
        match &self.conn {
            #[cfg(feature = "transport_usb")]
            ConnInfo::Usb(_) => ConnType::Usb,
            #[cfg(feature = "transport_tcp")]
            ConnInfo::Tcp(_) => ConnType::Tcp,
            #[cfg(feature = "transport_ble")]
            ConnInfo::Ble(_) => ConnType::Ble,
        }
    }
}

/// Ledger device models
#[derive(Clone, PartialEq, Debug, Display, EnumString)]
pub enum Model {
    /// Nano S
    NanoS,
    /// Nano S Plus
    NanoSPlus,
    /// Nano X
    NanoX,
    /// Stax
    Stax,
    /// Unknown model
    Unknown(u16),
}

impl Model {
    /// Convert a USB PID to a [Model] kind
    ///
    /// Note that ledger PIDs vary depending on the device state so only the top byte is used
    /// for matching.
    pub fn from_pid(pid: u16) -> Model {
        match pid & 0xFF00 {
            // TODO: support all the models
            //0x0001 => Ok(Model::NanoS),
            0x4000 => Model::NanoX,
            0x5000 => Model::NanoSPlus,
            //0x0006 => Ok(Model::Stax),
            _ => Model::Unknown(pid),
        }
    }
}

/// Ledger connection information
#[derive(Clone, PartialEq, Debug)]
pub enum ConnInfo {
    #[cfg(feature = "transport_usb")]
    Usb(transport::UsbInfo),
    #[cfg(feature = "transport_tcp")]
    Tcp(transport::TcpInfo),
    #[cfg(feature = "transport_ble")]
    Ble(transport::BleInfo),
}

/// Ledger connection types
#[derive(Copy, Clone, PartialEq, Debug)]
pub enum ConnType {
    Usb,
    Tcp,
    Ble,
}

impl From<ConnType> for Filters {
    /// Convert a connection type to a discovery filter
    fn from(value: ConnType) -> Self {
        match value {
            ConnType::Usb => Filters::Hid,
            ConnType::Tcp => Filters::Tcp,
            ConnType::Ble => Filters::Ble,
        }
    }
}

impl std::fmt::Display for ConnInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            #[cfg(feature = "transport_usb")]
            Self::Usb(i) => write!(f, "HID {}", i),
            #[cfg(feature = "transport_tcp")]
            Self::Tcp(i) => write!(f, "TCP {}", i),
            #[cfg(feature = "transport_ble")]
            Self::Ble(i) => write!(f, "BLE {}", i),
        }
    }
}

#[cfg(feature = "transport_usb")]
impl From<transport::UsbInfo> for ConnInfo {
    fn from(value: transport::UsbInfo) -> Self {
        Self::Usb(value)
    }
}

#[cfg(feature = "transport_tcp")]
impl From<transport::TcpInfo> for ConnInfo {
    fn from(value: transport::TcpInfo) -> Self {
        Self::Tcp(value)
    }
}

#[cfg(feature = "transport_ble")]
impl From<transport::BleInfo> for ConnInfo {
    fn from(value: transport::BleInfo) -> Self {
        Self::Ble(value)
    }
}

/// Application info object
#[derive(Debug, Clone, PartialEq)]
pub struct AppInfo {
    pub name: String,
    pub version: String,
    pub flags: ledger_proto::apdus::AppFlags,
}

/// Device info object
#[derive(Debug, Clone, PartialEq)]
pub struct DeviceInfo {
    pub target_id: [u8; 4],
    pub se_version: String,
    pub mcu_version: String,
    pub flags: Vec<u8>,
}

================
File: lib/src/lib.rs
================
//! A Ledger hardware wallet communication library
//!
//! [Device] provides a high-level API for exchanging APDUs with Ledger devices using the [ledger_proto] traits.
//! This is suitable for extension with application-specific interface traits, and automatically
//! implemented over [Exchange] for low-level byte exchange with devices.
//!
//! [LedgerProvider] and [LedgerHandle] provide a high-level tokio-compatible [Transport]
//! for application integration, supporting connecting to and interacting with ledger devices.
//! This uses a pinned thread to avoid thread safety issues with `hidapi` and async executors.
//!
//! Low-level [Transport] implementations are provided for [USB/HID](transport::UsbTransport),
//! [BLE](transport::BleTransport) and [TCP](transport::TcpTransport), with a [Generic](transport::GenericTransport)
//! implementation providing a common interface over all enabled transports.
//!
//! ## Safety
//!
//! Transports are currently marked as `Send` due to limitations of [async_trait] and are NOT all
//! thread safe. If you're calling this from an async context, please use [LedgerProvider].
//!
//! This will be corrected when the unstable async trait feature is stabilised,
//! which until then can be opted-into using the `unstable_async_trait` feature
//!
//! ## Examples
//!
//! ```no_run
//! use ledger_lib::{LedgerProvider, Filters, Transport, Device, DEFAULT_TIMEOUT};
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     // Fetch provider handle
//!     let mut provider = LedgerProvider::init().await;
//!
//!     // List available devices
//!     let devices = provider.list(Filters::Any).await?;
//!
//!     // Check we have -a- device to connect to
//!     if devices.is_empty() {
//!         return Err(anyhow::anyhow!("No devices found"));
//!     }
//!
//!     // Connect to the first device
//!     let mut ledger = provider.connect(devices[0].clone()).await?;
//!
//!     // Request device information
//!     let info = ledger.app_info(DEFAULT_TIMEOUT).await?;
//!     println!("info: {info:?}");
//!
//!     Ok(())
//! }
//! ```

#![cfg_attr(feature = "unstable_async_trait", feature(async_fn_in_trait))]
#![cfg_attr(feature = "unstable_async_trait", feature(negative_impls))]

use std::time::Duration;

use tracing::debug;

use ledger_proto::{
    apdus::{ExitAppReq, RunAppReq},
    GenericApdu, StatusCode,
};

pub mod info;
pub use info::LedgerInfo;

mod error;
pub use error::Error;

pub mod transport;
pub use transport::Transport;

mod provider;
pub use provider::{LedgerHandle, LedgerProvider};

mod device;
pub use device::Device;

/// Default timeout helper for use with [Device] and [Exchange]
pub const DEFAULT_TIMEOUT: Duration = Duration::from_secs(3);

/// Device discovery filter
#[derive(Copy, Clone, Debug, PartialEq, strum::Display)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[non_exhaustive]
pub enum Filters {
    /// List all devices available using supported transport
    Any,
    /// List only HID devices
    Hid,
    /// List only TCP devices
    Tcp,
    /// List only BLE device
    Ble,
}

impl Default for Filters {
    fn default() -> Self {
        Self::Any
    }
}

/// [Exchange] trait provides a low-level interface for byte-wise exchange of APDU commands with a ledger devices
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
pub trait Exchange {
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error>;
}

/// Blanket [Exchange] impl for mutable references
#[cfg_attr(not(feature = "unstable_async_trait"), async_trait::async_trait)]
impl<T: Exchange + Send> Exchange for &mut T {
    async fn exchange(&mut self, command: &[u8], timeout: Duration) -> Result<Vec<u8>, Error> {
        <T as Exchange>::exchange(self, command, timeout).await
    }
}

/// Launch an application by name and return a device handle.
///
/// This checks whether an application is running, exits this if it
/// is not the desired application, then launches the specified app
/// by name.
///
/// # WARNING
/// Due to the constant re-enumeration of devices when changing app
/// contexts, and the lack of reported serial numbers by ledger devices,
/// this is not incredibly reliable. Use at your own risk.
///
pub async fn launch_app<T>(
    mut t: T,
    info: <T as Transport>::Info,
    app_name: &str,
    opts: &LaunchAppOpts,
    timeout: Duration,
) -> Result<<T as Transport>::Device, Error>
where
    T: Transport<Info = LedgerInfo, Filters = Filters> + Send,
    <T as Transport>::Device: Send,
{
    let mut buff = [0u8; 256];

    debug!("Connecting to {info:?}");

    // Connect to device and fetch the currently running application
    let mut d = t.connect(info.clone()).await?;
    let i = d.app_info(timeout).await?;

    // Early-return if we're already running the correct app
    if i.name == app_name {
        debug!("Already running app {app_name}");
        return Ok(d);
    }

    // Send an exit request to the running app
    if i.name != "BOLOS" {
        debug!("Exiting running app {}", i.name);

        match d
            .request::<GenericApdu>(ExitAppReq::new(), &mut buff, timeout)
            .await
        {
            Ok(_) | Err(Error::Status(StatusCode::Ok)) => (),
            Err(e) => return Err(e),
        }

        debug!("Exit complete, reconnecting to {info:?}");

        // Close and re-connect to the device
        drop(d);

        tokio::time::sleep(Duration::from_secs(opts.reconnect_delay_s as u64)).await;

        d = reconnect(&mut t, info.clone(), opts).await?;
    }

    // Send run request
    for i in 0..10 {
        debug!("Issuing run request ({i}/10)");

        let resp = d
            .request::<GenericApdu>(RunAppReq::new(app_name), &mut buff, timeout)
            .await;

        // Handle responses
        match resp {
            // Ok response or status, app opened
            Ok(_) | Err(Error::Status(StatusCode::Ok)) => {
                debug!("Run request complete, reconnecting to {info:?}");

                // Re-connect to the device following app loading
                drop(d);

                tokio::time::sleep(Duration::from_secs(opts.reconnect_delay_s as u64)).await;

                d = reconnect(&mut t, info.clone(), opts).await?;

                return Ok(d);
            }
            // Empty response, pending reply
            Err(Error::EmptyResponse) => tokio::time::sleep(Duration::from_secs(1)).await,
            // Error response, something failed
            Err(e) => return Err(e),
        }
    }

    Err(Error::Timeout)
}

pub struct LaunchAppOpts {
    /// Delay prior to attempting device re-connection in seconds.
    ///
    /// This delay is required to allow the OS to re-enumerate the HID
    /// device.
    pub reconnect_delay_s: usize,

    /// Timeout for reconnect operations in seconds.
    pub reconnect_timeout_s: usize,
}

impl Default for LaunchAppOpts {
    fn default() -> Self {
        Self {
            reconnect_delay_s: 3,
            reconnect_timeout_s: 10,
        }
    }
}

/// Helper to reconnect to devices
async fn reconnect<T: Transport<Info = LedgerInfo, Filters = Filters>>(
    mut t: T,
    info: LedgerInfo,
    opts: &LaunchAppOpts,
) -> Result<<T as Transport>::Device, Error> {
    let mut new_info = None;

    // Build filter based on device connection type
    let filters = Filters::from(info.kind());

    debug!("Starting reconnect");

    // Await device reconnection
    for i in 0..opts.reconnect_timeout_s {
        debug!("Listing devices ({i}/{})", opts.reconnect_timeout_s);

        // List available devices
        let devices = t.list(filters).await?;

        // Look for matching device listing
        // We can't use -paths- here because the VID changes on launch
        // nor device serials, because these are always set to 1 (?!)
        match devices
            .iter()
            .find(|i| i.model == info.model && i.kind() == info.kind())
        {
            Some(i) => {
                new_info = Some(i.clone());
                break;
            }
            None => tokio::time::sleep(Duration::from_secs(1)).await,
        };
    }

    let new_info = match new_info {
        Some(v) => v,
        None => return Err(Error::Closed),
    };

    debug!("Device found, reconnecting!");

    // Connect to device using new information object
    let d = t.connect(new_info).await?;

    // Return new device connection
    Ok(d)
}

================
File: lib/Cargo.toml
================
[package]
name = "ledger-lib"
description = "Communication library for Ledger hardware wallets"
repository = "https://github.com/ledger-community/rust-ledger.git"
keywords = [ "ledger", "wallet", "usb", "hid", "bluetooth" ]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"

[features]
# Select enabled transports
transport_usb = [ "hidapi" ]
transport_tcp = []
transport_ble = [ "btleplug" ]

# Switch libusb backends, `libusb` works better with WSL so we're using that by default
transport_usb_libusb = [ "hidapi/linux-static-libusb" ]
transport_usb_hidraw = [ "hidapi/linux-static-hidraw" ]

# Enable `clap` attributes on exported objects
clap = [ "dep:clap" ]

# enable `async_fn_in_trait` nightly feature, removes need for `async_trait` macros
unstable_async_trait = []

default = [ "transport_usb", "transport_tcp", "transport_ble", "transport_usb_libusb" ]

[dependencies]

thiserror = "1.0.40"
encdec = "0.9.0"
ledger-proto = { version = "0.1.0", default-features = false, features = [ "std" ] }
tracing = "0.1.37"
tracing-subscriber = { version = "0.3.16", features = ["env-filter"] }
strum = { version = "0.24.1", features = ["derive"] }
tokio = { version = "1.27.0", features = ["full"] }
once_cell = "1.17.1"
uuid = "1.3.2"
futures = "0.3.28"
async-trait = "0.1.68"
displaydoc = "0.2.4"

clap = { version = "4.2.2", optional = true }
hidapi = { version = "2.1.2", optional = true, default-features = false }
btleplug = { version = "0.10.5", optional = true }


[dev-dependencies]
anyhow = "1.0.71"

================
File: proto/src/apdus/app_info.rs
================
//! Application information request and response APDUs

use encdec::{Decode, Encode};

use crate::{ApduError, ApduStatic};

/// Application information request APDU
#[derive(Clone, Debug, PartialEq, Encode, Decode)]
#[encdec(error = "ApduError")]
pub struct AppInfoReq {}

/// Set CLA and INS values for [AppInfoReq]
impl ApduStatic for AppInfoReq {
    /// Application Info GET APDU is class `0xb0`
    const CLA: u8 = 0xb0;

    /// Application Info GET APDU is instruction `0x00`
    const INS: u8 = 0x01;
}

/// Application information response APDU
#[derive(Debug, PartialEq)]
pub struct AppInfoResp<'a> {
    /// Application name
    pub name: &'a str,
    /// Application version
    pub version: &'a str,
    /// Application flags
    pub flags: AppFlags,
}

bitflags::bitflags! {
    /// Application info flags
    #[derive(Clone, Debug, PartialEq)]
    #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
    pub struct AppFlags: u8 {
        /// Recovery mode
        const RECOVERY = 1 << 0;
        /// Signed application
        const SIGNED = 1 << 1;
        /// User onboarded
        const ONBOARDED = 1 << 2;
        /// ??
        const TRUST_ISSUER = 1 << 3;
        /// ??
        const TRUST_CUSTOM_CA = 1 << 4;
        /// HSM initialised
        const HSM_INITIALISED = 1 << 5;
        /// PIN validated
        const PIN_VALIDATED = 1 << 7;
    }
}

impl<'a> AppInfoResp<'a> {
    /// Create a new application version APDU
    pub fn new(name: &'a str, version: &'a str, flags: AppFlags) -> Self {
        Self {
            name,
            version,
            flags,
        }
    }
}

const APP_VERSION_FMT: u8 = 1;

impl<'a> Encode for AppInfoResp<'a> {
    type Error = ApduError;

    fn encode_len(&self) -> Result<usize, Self::Error> {
        let mut len = 0;

        len += 1;
        len += 1 + self.name.len();
        len += 1 + self.version.len();
        len += 2;

        Ok(len)
    }

    fn encode(&self, buff: &mut [u8]) -> Result<usize, Self::Error> {
        if buff.len() < self.encode_len()? {
            return Err(ApduError::InvalidLength);
        }

        let mut index = 0;
        buff[0] = APP_VERSION_FMT;
        index += 1;

        buff[index] = self.name.len() as u8;
        buff[index + 1..][..self.name.len()].copy_from_slice(self.name.as_bytes());
        index += 1 + self.name.len();

        buff[index] = self.version.len() as u8;
        buff[index + 1..][..self.version.len()].copy_from_slice(self.version.as_bytes());
        index += 1 + self.version.len();

        buff[index] = 1;
        buff[index + 1] = self.flags.bits();
        index += 2;

        Ok(index)
    }
}

impl<'a> Decode<'a> for AppInfoResp<'a> {
    type Output = Self;

    type Error = ApduError;

    fn decode(buff: &'a [u8]) -> Result<(Self::Output, usize), Self::Error> {
        let mut index = 0;

        // Check app version format
        if buff[index] != APP_VERSION_FMT {
            return Err(ApduError::InvalidVersion(buff[index]));
        }
        index += 1;

        // Fetch name string
        let name_len = buff[index] as usize;
        let name = core::str::from_utf8(&buff[index + 1..][..name_len])
            .map_err(|_| ApduError::InvalidUtf8)?;
        index += 1 + name_len;

        // Fetch version string
        let version_len = buff[index] as usize;
        let version = core::str::from_utf8(&buff[index + 1..][..version_len])
            .map_err(|_| ApduError::InvalidUtf8)?;
        index += 1 + version_len;

        // Fetch flags (if available)
        let flags = if buff.len() > index {
            let flags_len = buff[index];
            let flags = AppFlags::from_bits_truncate(buff[index + 1]);
            index += 1 + flags_len as usize;
            flags
        } else {
            AppFlags::empty()
        };

        Ok((
            Self {
                name,
                version,
                flags,
            },
            index,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn app_info_resp() {
        let r = AppInfoResp::new("test name", "test version", AppFlags::ONBOARDED);

        let mut buff = [0u8; 256];
        crate::tests::encode_decode(&mut buff, r);
    }
}

================
File: proto/src/apdus/device_info.rs
================
//! Device information request and response APDUs

use encdec::{Decode, Encode};

use crate::{ApduError, ApduStatic};

/// Device info APDU command
#[derive(Copy, Clone, PartialEq, Debug, Default, Encode, Decode)]
#[encdec(error = "ApduError")]
pub struct DeviceInfoReq {}

impl ApduStatic for DeviceInfoReq {
    /// Device info request APDU is class `0xe0`
    const CLA: u8 = 0xe0;

    /// Device info request APDU is instruction `0x01`
    const INS: u8 = 0x01;
}

/// Device info APDU response
#[derive(Copy, Clone, PartialEq, Debug)]
pub struct DeviceInfoResp<'a> {
    /// Target ID
    pub target_id: [u8; 4],

    /// Secure Element Version
    pub se_version: &'a str,

    /// Device Flag(s)
    pub flags: &'a [u8],

    /// MCU Version
    pub mcu_version: &'a str,
}

impl<'a> DeviceInfoResp<'a> {
    /// Create a new device info APDU
    pub fn new(
        target_id: [u8; 4],
        se_version: &'a str,
        mcu_version: &'a str,
        flags: &'a [u8],
    ) -> Self {
        Self {
            target_id,
            se_version,
            mcu_version,
            flags,
        }
    }
}

impl<'a> Encode for DeviceInfoResp<'a> {
    type Error = ApduError;

    /// Encode an device info APDU into the provided buffer
    fn encode(&self, buff: &mut [u8]) -> Result<usize, ApduError> {
        // Check buffer length is viable
        if buff.len() < self.encode_len()? {
            return Err(ApduError::InvalidLength);
        }

        let mut index = 0;

        // Write target ID
        buff[index..][..4].copy_from_slice(&self.target_id);
        index += 4;

        // Write SE version
        buff[index] = self.se_version.len() as u8;
        buff[index + 1..][..self.se_version.len()].copy_from_slice(self.se_version.as_bytes());
        index += 1 + self.se_version.len();

        // Write flags
        buff[index] = self.flags.len() as u8;
        buff[index + 1..][..self.flags.len()].copy_from_slice(self.flags);
        index += 1 + self.flags.len();

        // Write MCU version
        buff[index] = self.mcu_version.len() as u8;
        buff[index + 1..][..self.mcu_version.len()].copy_from_slice(self.mcu_version.as_bytes());
        index += 1 + self.mcu_version.len();

        Ok(index)
    }

    /// Compute APDU encoded length
    fn encode_len(&self) -> Result<usize, ApduError> {
        let mut len = 4;

        len += 1 + self.se_version.len();
        len += 1 + self.flags.len();
        len += 1 + self.mcu_version.len();

        Ok(len)
    }
}

impl<'a> Decode<'a> for DeviceInfoResp<'a> {
    type Output = Self;
    type Error = ApduError;

    /// Decode an device info APDU from the provided buffer
    fn decode(buff: &'a [u8]) -> Result<(Self, usize), ApduError> {
        let mut index = 0;

        // Fetch target id
        let mut target_id = [0u8; 4];
        target_id.copy_from_slice(&buff[..4]);
        index += 4;

        // Fetch secure element version
        let se_version_len = buff[index] as usize;
        let se_version = core::str::from_utf8(&buff[index + 1..][..se_version_len])
            .map_err(|_| ApduError::InvalidUtf8)?;
        index += 1 + se_version_len;

        // Fetch flags
        let flags_len = buff[index] as usize;
        let flags = &buff[index + 1..][..flags_len];
        index += 1 + flags_len;

        // Fetch mcu version
        let mcu_version_len = buff[index] as usize;
        let mcu_version = core::str::from_utf8(&buff[index + 1..][..mcu_version_len])
            .map_err(|_| ApduError::InvalidUtf8)?;
        index += 1 + mcu_version_len;

        Ok((
            Self {
                target_id,
                se_version,
                flags,
                mcu_version,
            },
            index,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn device_info_resp() {
        let r = DeviceInfoResp::new([0x01, 0x02, 0x03, 0x04], "SOME SE", "SOME MCU", &[0xaa]);

        let mut buff = [0u8; 256];
        crate::tests::encode_decode(&mut buff, r);
    }
}

================
File: proto/src/apdus/exit_app.rs
================
//! Exit application APDU

use encdec::{DecodeOwned, Encode};

use crate::{ApduError, ApduStatic};

/// Exit application request APDU, used to exit a running application
///
/// Note this is not supported by _all_ applications
#[derive(Clone, Debug, PartialEq, Default, Encode, DecodeOwned)]
#[encdec(error = "ApduError")]
pub struct ExitAppReq {}

/// Set CLA and INS values for [ExitAppReq]
impl ApduStatic for ExitAppReq {
    const CLA: u8 = 0xb0;
    const INS: u8 = 0xa7;
}

impl ExitAppReq {
    /// Create a new exit application request
    pub fn new() -> Self {
        Self {}
    }
}

================
File: proto/src/apdus/mod.rs
================
//! Ledger common APDU definitions

mod app_info;
pub use app_info::{AppFlags, AppInfoReq, AppInfoResp};

mod device_info;
pub use device_info::{DeviceInfoReq, DeviceInfoResp};

mod run_app;
pub use run_app::RunAppReq;

mod exit_app;
pub use exit_app::ExitAppReq;

================
File: proto/src/apdus/run_app.rs
================
//! Run application APDU

use encdec::{Decode, Encode};

use crate::{ApduError, ApduStatic};

/// Run application request APDU, request to BOLOS to launch an application on the Ledger Device
#[derive(Clone, Debug, PartialEq, Encode)]
#[encdec(error = "ApduError")]
pub struct RunAppReq<'a> {
    /// Application name to launch (note this is case sensitive)
    pub app_name: &'a str,
}

/// Set CLA and INS values for [RunAppReq]
impl<'a> ApduStatic for RunAppReq<'a> {
    const CLA: u8 = 0xe0;
    const INS: u8 = 0xd8;
}

impl<'a> RunAppReq<'a> {
    /// Create a new run application request APDU
    pub fn new(app_name: &'a str) -> Self {
        Self { app_name }
    }
}

impl<'a> Decode<'a> for RunAppReq<'a> {
    type Output = Self;

    type Error = ApduError;

    fn decode(buff: &'a [u8]) -> Result<(Self::Output, usize), Self::Error> {
        let app_name = match core::str::from_utf8(buff) {
            Ok(v) => v,
            Err(_e) => return Err(ApduError::InvalidUtf8),
        };

        Ok((Self { app_name }, buff.len()))
    }
}

#[cfg(test)]
mod test {
    use super::RunAppReq;

    #[test]
    fn encode_decode_run_app_req() {
        let r = RunAppReq::new("test app");

        let mut buff = [0u8; 256];
        crate::tests::encode_decode(&mut buff, r);
    }
}

================
File: proto/src/error.rs
================
//! Apdu error information for encoding / decoding etc.

/// APDU error type
#[derive(Debug, displaydoc::Display)]
#[cfg_attr(feature = "std", derive(thiserror::Error))]
pub enum ApduError {
    /// Invalid buffer length
    InvalidLength,

    /// Invalid Utf8 string encoding
    InvalidUtf8,

    /// Invalid APDU encoding version {0}
    InvalidVersion(u8),

    /// Invalid APDU encoding
    InvalidEncoding,
}

impl From<encdec::Error> for ApduError {
    fn from(value: encdec::Error) -> Self {
        match value {
            encdec::Error::Length => Self::InvalidLength,
            encdec::Error::Utf8 => Self::InvalidUtf8,
        }
    }
}

================
File: proto/src/lib.rs
================
//! Ledger Hardware Wallet APDU traits and shared types.
//!
//! This provides abstractions for encoding and decoding APDUs for to
//! support interaction with Ledger devices.
//!
//! APDUs must implement [ApduBase] as well as [encdec::Encode] and [encdec::Decode]
//! (or [encdec::DecodeOwned]) for binary serialisation, with commands providing
//! header information via [ApduReq].
//! [encdec::Encode] and [encdec::Decode] can be automatically derived using `encdec` macros,
//! or manually implemented over existing objects / encodings.
//!
//! An [ApduStatic] helper is provided to automatically implement [ApduReq] for APDU requests
//! with static headers and a common [ApduError] type is provided to unify serialisation and
//! deserialisation errors across APDU objects.
//!
//!
//! ## Examples
//!
//! Command APDU (no body) using [ApduStatic]:
//!
//! ```
//! use ledger_proto::{ApduStatic, ApduError, Encode, DecodeOwned};
//!
//! /// Application information request APDU
//! #[derive(Clone, Debug, PartialEq, Encode, DecodeOwned)]
//! #[encdec(error = "ApduError")]
//! pub struct AppInfoReq {}
//!
//! /// Set CLA and INS values for [AppInfoReq]
//! impl ApduStatic for AppInfoReq {
//!     /// Application Info GET APDU is class `0xb0`
//!     const CLA: u8 = 0xb0;
//!     /// Application Info GET APDU is instruction `0x00`
//!     const INS: u8 = 0x01;
//! }
//! ```
//!
//! Manual response APDU implementation
//!
//! ```
//! use ledger_proto::{ApduStatic, ApduError, Encode, Decode};
//!
//! /// Example response APDU
//! #[derive(Clone, Debug, PartialEq)]
//! pub struct StringResp<'a> {
//!     pub value: &'a str,
//! }
//!
//! /// [Encode] implementation for [StringResp]
//! impl <'a> Encode for StringResp<'a> {
//!   type Error = ApduError;
//!
//!   /// Fetch encoded length
//!   fn encode_len(&self) -> Result<usize, Self::Error> {
//!       Ok(1 + self.value.as_bytes().len())
//!   }
//!
//!   /// Encode to bytes
//!   fn encode(&self, buff: &mut [u8]) -> Result<usize, Self::Error> {
//!     let b = self.value.as_bytes();
//!
//!     // Check buffer length is valid
//!     if buff.len() < self.encode_len()?
//!         || b.len() > u8::MAX as usize {
//!       return Err(ApduError::InvalidLength);
//!     }
//!
//!     // Write value length
//!     buff[0] = b.len() as u8;
//!
//!     // Write value
//!     buff[1..][..b.len()]
//!         .copy_from_slice(b);
//!
//!     Ok(1 + b.len())
//!   }
//! }
//!
//! impl <'a> Decode<'a> for StringResp<'a> {
//!    type Output = Self;
//!    type Error = ApduError;
//!
//!     fn decode(buff: &'a [u8]) -> Result<(Self::Output, usize), Self::Error> {
//!         // Check buffer length
//!         if buff.len() < 1 {
//!             return Err(ApduError::InvalidLength);
//!         }
//!         let n = buff[0]as usize;
//!         if n + 1 > buff.len() {
//!             return Err(ApduError::InvalidLength);
//!         }
//!
//!         // Parse string value
//!         let s = match core::str::from_utf8(&buff[1..][..n]) {
//!             Ok(v) => v,
//!             Err(_) => return Err(ApduError::InvalidUtf8),
//!         };
//!
//!         // Return object and parsed length
//!         Ok((Self{ value: s}, n + 1))
//!    }
//! }
//! ```
//!
//! For more examples, see the shared APDUs provided in the [apdus] module.
//!

#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "alloc")]
extern crate alloc;
#[cfg(feature = "alloc")]
use alloc::vec::Vec;

pub use encdec::{Decode, DecodeOwned, EncDec, Encode};

mod error;
pub use error::ApduError;

pub mod apdus;

mod status;
pub use status::StatusCode;

/// APDU command header
#[derive(Copy, Clone, PartialEq, Debug, Default, Encode, DecodeOwned)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[encdec(error = "ApduError")]
pub struct ApduHeader {
    /// Class ID
    pub cla: u8,
    /// Instruction ID
    pub ins: u8,
    /// Parameter 1
    pub p1: u8,
    /// Parameter 2
    pub p2: u8,
}

/// Helper trait for defining static APDU commands, automatically
/// implements [ApduReq].
///
/// ```
/// use ledger_proto::{ApduStatic, ApduError, Encode, Decode};
///
/// // App information request APDU (no body)
/// #[derive(Clone, Debug, PartialEq, Encode, Decode)]
/// #[encdec(error = "ApduError")]
/// pub struct AppInfoReq {}
///
/// /// Set CLA and INS values for [AppInfoReq]
/// impl ApduStatic for AppInfoReq {
///     /// Application Info GET APDU is class `0xb0`
///     const CLA: u8 = 0xb0;
///
///     /// Application Info GET APDU is instruction `0x00`
///     const INS: u8 = 0x01;
/// }
/// ```
pub trait ApduStatic {
    /// Class ID for APDU commands
    const CLA: u8;

    /// Instruction ID for APDU commands
    const INS: u8;

    /// Fetch P1 value (defaults to `0` if not extended)
    fn p1(&self) -> u8 {
        0
    }

    /// Fetch P2 value (defaults to `0` if not extended)
    fn p2(&self) -> u8 {
        0
    }
}

/// Generic APDU request trait
pub trait ApduReq<'a>: EncDec<'a, ApduError> {
    /// Fetch the [ApduHeader] for a given APDU request
    fn header(&self) -> ApduHeader;
}

/// Blanket [ApduReq] impl for [ApduStatic] types
impl<'a, T: EncDec<'a, ApduError> + ApduStatic> ApduReq<'a> for T {
    fn header(&self) -> ApduHeader {
        ApduHeader {
            cla: T::CLA,
            ins: T::INS,
            p1: self.p1(),
            p2: self.p2(),
        }
    }
}

/// Generic APDU base trait, auto-implemented where `T: EncDec<'a, ApduError>`
pub trait ApduBase<'a>: EncDec<'a, ApduError> {}

/// Blanket [ApduBase] implementation
impl<'a, T: EncDec<'a, ApduError>> ApduBase<'a> for T {}

/// Generic APDU object (enabled with `alloc` feature), prefer use of strict APDU types where possible
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg(feature = "alloc")]
pub struct GenericApdu {
    /// Request APDU Header (uses [Default] for incoming / response APDUs)
    pub header: ApduHeader,
    /// APDU data
    #[cfg_attr(feature = "serde", serde(with = "hex::serde"))]
    pub data: Vec<u8>,
}

/// [ApduReq] implementation for [GenericApdu], exposes internal header
#[cfg(feature = "alloc")]
impl<'a> ApduReq<'a> for GenericApdu {
    fn header(&self) -> ApduHeader {
        self.header
    }
}

/// [Encode] implementation for [GenericApdu]
#[cfg(feature = "alloc")]
impl Encode for GenericApdu {
    type Error = ApduError;

    fn encode_len(&self) -> Result<usize, Self::Error> {
        Ok(self.data.len())
    }

    fn encode(&self, buff: &mut [u8]) -> Result<usize, Self::Error> {
        // Check buffer length
        if buff.len() < self.data.len() {
            return Err(ApduError::InvalidLength);
        }
        // Copy data
        buff[..self.data.len()].copy_from_slice(&self.data);
        // Return write length
        Ok(self.data.len())
    }
}

/// [DecodeOwned] implementation for [GenericApdu]
#[cfg(feature = "alloc")]
impl DecodeOwned for GenericApdu {
    type Output = Self;

    type Error = ApduError;

    fn decode_owned(buff: &[u8]) -> Result<(Self::Output, usize), Self::Error> {
        let data = buff.to_vec();
        Ok((
            Self {
                header: Default::default(),
                data,
            },
            buff.len(),
        ))
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;
    use encdec::EncDec;

    /// Helper to test round-trip encode / decode for APDUS
    pub fn encode_decode<'a, A: EncDec<'a, ApduError> + PartialEq>(buff: &'a mut [u8], a: A) {
        // Test encoding
        let n = a.encode(buff).unwrap();

        // Test decoding
        let (a1, n1) = A::decode(&buff[..n]).unwrap();

        // Compare results
        assert_eq!(n1, n);
        assert_eq!(a1, a);
    }

    #[test]
    fn header_encode_decode() {
        let h = ApduHeader {
            cla: 1,
            ins: 2,
            p1: 3,
            p2: 4,
        };

        let mut b = [0u8; 4];

        encode_decode(&mut b, h);

        assert_eq!(&b, &[1, 2, 3, 4]);
    }
}

================
File: proto/src/status.rs
================
/// Device status codes (two bytes, trailing response data)
///
/// Replicated from: https://github.com/LedgerHQ/ledger-live/blob/develop/libs/ledgerjs/packages/errors/src/index.ts#L212
#[derive(Copy, Clone, Debug, displaydoc::Display, num_enum::TryFromPrimitive)]
#[repr(u16)]
pub enum StatusCode {
    /// Access condition not fulfilled
    AccessConditionNotFulfilled = 0x9804,
    /// Algorithm not supported
    AlgorithmNotSupported = 0x9484,
    /// APDU class not supported
    ClaNotSupported = 0x6e00,
    /// Code blocked
    CodeBlocked = 0x9840,
    /// Code not initialized
    CodeNotInitialized = 0x9802,
    /// Command incompatible file structure
    CommandIncompatibleFileStructure = 0x6981,
    /// Conditions of use not satisfied
    ConditionsOfUseNotSatisfied = 0x6985,
    /// Contradiction invalidation
    ContradictionInvalidation = 0x9810,
    /// Contradiction secret code status
    ContradictionSecretCodeStatus = 0x9808,
    /// Custom image bootloader
    CustomImageBootloader = 0x662f,
    /// Custom image empty
    CustomImageEmpty = 0x662e,
    /// File already exists
    FileAlreadyExists = 0x6a89,
    /// File not found
    FileNotFound = 0x9404,
    /// GP auth failed
    GpAuthFailed = 0x6300,
    /// Device halted
    Halted = 0x6faa,
    /// Inconsistent file
    InconsistentFile = 0x9408,
    /// Incorrect data
    IncorrectData = 0x6a80,
    /// Incorrect length
    IncorrectLength = 0x6700,
    /// Incorrect P1 or P2 values
    IncorrectP1P2 = 0x6b00,
    /// Instruction not supported
    InsNotSupported = 0x6d00,
    /// Device not onboarded
    DeviceNotOnboarded = 0x6d07,
    /// Device also not onboarded
    DeviceNotOnboarded2 = 0x6611,
    /// Invalid KCV
    InvalidKcv = 0x9485,
    /// Invalid offset
    InvalidOffset = 0x9402,
    /// Licensing error
    Licensing = 0x6f42,
    /// Device locked
    LockedDevice = 0x5515,
    /// Max value reached
    MaxValueReached = 0x9850,
    /// Memory problem
    MemoryProblem = 0x9240,
    /// Missing critical parameter
    MissingCriticalParameter = 0x6800,
    /// No EF selected
    NoEfSelected = 0x9400,
    /// Not enough memory space
    NotEnoughMemorySpace = 0x6a84,
    /// OK
    Ok = 0x9000,
    /// Remaining PIN attempts
    PinRemainingAttempts = 0x63c0,
    /// Referenced data not found
    ReferencedDataNotFound = 0x6a88,
    /// Security status not satisfied
    SecurityStatusNotSatisfied = 0x6982,
    /// Technical problem
    TechnicalProblem = 0x6f00,
    /// Unknown APDU
    UnknownApdu = 0x6d02,
    /// User refused on device
    UserRefusedOnDevice = 0x5501,
    /// Not enough space
    NotEnoughSpace = 0x5102,
}

================
File: proto/Cargo.toml
================
[package]
name = "ledger-proto"
description = "Ledger hardware wallet protocol / APDU definitions"
repository = "https://github.com/ledger-community/rust-ledger.git"
keywords = [ "ledger", "protocol", "apdu" ]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"

[features]
# `std` feature implements `std::error::Error` for `ApduError` type
std = [ "dep:thiserror", "alloc" ]
# `alloc` feature gates `Vec` based types
alloc = []
# `serde` feature enables object serialisation and deserialisation
serde = [ "dep:serde", "dep:hex", "bitflags/serde" ]

default = [ "std", "serde" ]

[dependencies]
encdec = { version = "0.9.0", default-features = false }
bitflags = { version = "2.1.0", default-features = false }
displaydoc = { version = "0.2.3", default-features = false }
num_enum = { version = "0.6.1", default-features = false }

serde = { version = "1.0.166", features = ["derive"], optional = true }
hex = { version = "0.4.3", features = ["serde"], optional = true }
thiserror = { version = "1.0.40", optional = true }

================
File: sim/src/drivers/docker.rs
================
//! Docker driver for speculos execution, runs a speculos instance within
//! a Docker container.

use std::{
    collections::HashMap,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    path::PathBuf,
    time::Duration,
};

use async_trait::async_trait;
use bollard::{
    container::{
        Config, CreateContainerOptions, LogsOptions, RemoveContainerOptions, StartContainerOptions,
        StopContainerOptions, UploadToContainerOptions,
    },
    service::{ContainerStateStatusEnum, HostConfig, PortBinding},
    Docker,
};
use bytes::{BufMut, BytesMut};
use futures::StreamExt;
use tokio::sync::oneshot::{channel, Sender};
use tracing::debug;

use super::Driver;
use crate::{Handle, Options};

/// Docker-based Speculos driver
pub struct DockerDriver {
    d: Docker,
}

/// Handle to a Speculos instance running under Docker
#[derive(Debug)]
pub struct DockerHandle {
    name: String,
    addr: SocketAddr,
    exit_tx: Sender<()>,
}

impl DockerDriver {
    /// Create a new docker driver
    pub fn new() -> Result<Self, anyhow::Error> {
        // Connect to docker instance
        let d = Docker::connect_with_local_defaults()?;

        // Return driver
        Ok(Self { d })
    }
}

const DEFAULT_IMAGE: &str = "ghcr.io/ledgerhq/speculos";

/// [Driver] implementation for [DockerDriver]
#[async_trait]
impl Driver for DockerDriver {
    type Handle = DockerHandle;

    async fn run(&self, app: &str, opts: Options) -> anyhow::Result<Self::Handle> {
        // Set container name
        let name = format!("speculos-{}", opts.http_port);
        let create_options = Some(CreateContainerOptions { name: &name });

        // Setup ports
        let mut ports = vec![opts.http_port];
        if let Some(p) = opts.apdu_port {
            ports.push(p);
        }

        let exposed_ports = ports.iter().map(|p| {
            let b = PortBinding {
                host_port: Some(format!("{p}/tcp")),
                ..Default::default()
            };
            (format!("{p}/tcp"), vec![b], HashMap::<(), ()>::new())
        });

        let app_path = PathBuf::from(app);
        let app_file = app_path.file_name().and_then(|n| n.to_str()).unwrap();

        // Setup speculos command
        let mut cmd = vec![];
        cmd.append(&mut opts.args());
        cmd.push(format!("/app/{app_file}"));

        debug!("command: {}", cmd.join(" "));

        // Setup container
        let create_config = Config {
            image: Some(DEFAULT_IMAGE.to_string()),
            cmd: Some(cmd),
            attach_stdout: Some(true),
            attach_stderr: Some(true),
            stop_signal: Some("KILL".to_string()),
            exposed_ports: Some(HashMap::from_iter(
                exposed_ports.clone().map(|p| (p.0, p.2)),
            )),
            host_config: Some(HostConfig {
                port_bindings: Some(HashMap::from_iter(exposed_ports.map(|p| (p.0, Some(p.1))))),
                ..Default::default()
            }),
            ..Default::default()
        };

        // Remove existing container if there is one
        let _ = self
            .d
            .remove_container(
                &name,
                Some(RemoveContainerOptions {
                    force: true,
                    ..Default::default()
                }),
            )
            .await;

        // Create container
        debug!("Creating container {}", name);
        let _create_info = self
            .d
            .create_container(create_options, create_config)
            .await?;

        // Generate application archive
        let mut buff = BytesMut::new();
        let mut tar = tar::Builder::new((&mut buff).writer());

        tar.append_path_with_name(&app_path, format!("app/{app_file}"))?;

        tar.finish()?;
        drop(tar);

        // Write app archive to container
        let upload_options = UploadToContainerOptions {
            path: "/",
            ..Default::default()
        };
        self.d
            .upload_to_container(&name, Some(upload_options), buff.to_vec().into())
            .await?;

        // Start container
        debug!("Starting container {}", name);
        let _start_info = self
            .d
            .start_container(&name, None::<StartContainerOptions<String>>)
            .await?;

        debug!("Container started");

        let (exit_tx, mut exit_rx) = channel();

        // Setup log streaming task
        let mut logs = self.d.logs::<String>(
            &name,
            Some(LogsOptions {
                stderr: true,
                stdout: true,
                follow: true,
                ..Default::default()
            }),
        );

        tokio::task::spawn(async move {
            debug!("start log task");

            loop {
                tokio::select! {
                    // Fetch log entries
                    l = logs.next() => {
                        match l {
                            Some(Ok(v)) => print!("{v}"),
                            Some(Err(e)) => {
                                debug!("exit log task: {:?}", e);
                                break;
                            },
                            _ => continue,
                        }
                    },
                    // Handle exit signal
                    _ = &mut exit_rx => {
                        break;
                    }
                }
            }
        });

        // Return container handle
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), opts.http_port);
        Ok(DockerHandle {
            name,
            addr,
            exit_tx,
        })
    }

    async fn wait(&self, handle: &mut Self::Handle) -> anyhow::Result<()> {
        use ContainerStateStatusEnum::*;

        debug!("Awaiting container completion");

        // Poll container info periodically
        loop {
            // Fetch container info
            let info = self.d.inspect_container(&handle.name, None).await?;

            debug!("info: {:?}", info);

            // Return when container exits
            match info.state.and_then(|s| s.status) {
                Some(CREATED) | Some(RUNNING) => (),
                Some(_) => return Ok(()),
                _ => (),
            }

            // Sleep for a while
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    }

    async fn exit(&self, handle: Self::Handle) -> anyhow::Result<()> {
        // Stop container
        debug!("Stopping container {}", handle.name);

        // Send exit signal to log task
        let _ = handle.exit_tx.send(());

        // Send container stop signal
        let options = Some(StopContainerOptions { t: 0 });
        let _ = self.d.stop_container(&handle.name, options).await;

        // Remove container
        debug!("Removing container");
        let options = Some(RemoveContainerOptions {
            force: true,
            ..Default::default()
        });
        self.d.remove_container(&handle.name, options).await?;

        debug!("Container removed");

        Ok(())
    }
}

#[async_trait]
impl Handle for DockerHandle {
    fn addr(&self) -> SocketAddr {
        self.addr
    }
}

================
File: sim/src/drivers/local.rs
================
//! Local driver for speculos execution, runs a speculos instance from the
//! local environment.

use std::{
    net::{IpAddr, Ipv4Addr, SocketAddr},
    process::Stdio,
};

use async_trait::async_trait;
use tokio::process::{Child, Command};
use tracing::debug;

use super::Driver;
use crate::{Handle, Options};

/// Local (child process) based speculos driver
pub struct LocalDriver;

/// Handle to a speculos instance running locally (as a child process)
#[derive(Debug)]
pub struct LocalHandle {
    /// HTTP API socket address
    addr: SocketAddr,
    /// Child task handle
    child: Child,
}

impl LocalDriver {
    /// Create a new [LocalDriver]
    pub fn new() -> Self {
        Self
    }
}

impl Default for LocalDriver {
    /// Create a new [LocalDriver]
    fn default() -> Self {
        Self
    }
}

/// [Driver] implementation for [LocalDriver]
#[async_trait]
impl Driver for LocalDriver {
    type Handle = LocalHandle;

    async fn run(&self, app: &str, opts: Options) -> anyhow::Result<Self::Handle> {
        // Setup speculos command
        let mut cmd = Command::new("speculos.py");

        // Kill when object is dropped
        let mut cmd = cmd.kill_on_drop(true);

        // Bind stdout / stderr
        // NOTE: for reasons unknown test harnesses don't overwrite stdout so much as hack the `print!` family of functions, so... this always produces a pile of output
        // TODO: it'd be nice to route this via the captured log output were it one day possible to do so
        cmd = cmd.stdout(Stdio::inherit()).stderr(Stdio::inherit());

        // Setup speculos arguments
        for a in opts.args() {
            cmd = cmd.arg(a);
        }

        if let Some(root) = opts.root {
            // Fetch existing path
            let (_, path) = std::env::vars()
                .find(|(k, _v)| k == "PATH")
                .unwrap_or(("PATH".to_string(), "".to_string()));

            cmd = cmd.env("PATH", format!("{path}:{root}"));
        }

        // Set application to execute
        cmd = cmd.arg(app);

        debug!("Command: {:?}", cmd);

        // Launch speculos and return
        let child = cmd.spawn()?;

        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), opts.http_port);
        Ok(LocalHandle { child, addr })
    }

    async fn wait(&self, handle: &mut Self::Handle) -> anyhow::Result<()> {
        let _status = handle.child.wait().await?;

        // TODO: match on status / return errors

        Ok(())
    }

    async fn exit(&self, mut handle: Self::Handle) -> anyhow::Result<()> {
        handle.child.kill().await?;
        Ok(())
    }
}

#[async_trait]
impl Handle for LocalHandle {
    fn addr(&self) -> SocketAddr {
        self.addr
    }
}

================
File: sim/src/drivers/mod.rs
================
//! Drivers for speculos runtime execution

use core::fmt::Debug;

use async_trait::async_trait;
use strum::{Display, EnumString, EnumVariantNames};

use crate::Options;

mod local;
pub use local::{LocalDriver, LocalHandle};

mod docker;
pub use docker::{DockerDriver, DockerHandle};

/// Mode selector for generic drivers
#[derive(Copy, Clone, PartialEq, Debug, clap::ValueEnum, EnumString, EnumVariantNames, Display)]
#[strum(serialize_all = "lowercase")]
pub enum DriverMode {
    /// Run Speculos as child process (requires that `speculos.py` is available on the PATH)
    Local,
    /// Run Speculos via docker container
    Docker,
}

/// [`Driver`] trait for speculos providers
#[async_trait]
pub trait Driver {
    type Handle: Debug;

    /// Run speculos with the specified app and options
    async fn run(&self, app: &str, opts: Options) -> anyhow::Result<Self::Handle>;

    /// Wait for task exit / completion
    async fn wait(&self, handle: &mut Self::Handle) -> anyhow::Result<()>;

    /// Exit task
    async fn exit(&self, mut handle: Self::Handle) -> anyhow::Result<()>;
}

/// Generic driver helper, allows implementations to be abstract over
/// concrete driver types
pub enum GenericDriver {
    Local(LocalDriver),
    Docker(DockerDriver),
}

impl GenericDriver {
    /// Create a new [GenericDriver] with the specified [DriverMode]
    pub fn new(mode: DriverMode) -> Result<Self, anyhow::Error> {
        let d = match mode {
            DriverMode::Local => Self::Local(LocalDriver::new()),
            DriverMode::Docker => Self::Docker(DockerDriver::new()?),
        };
        Ok(d)
    }
}

/// Generic Handle helper for use with [GenericDriver]
#[derive(Debug)]
pub enum GenericHandle {
    Local(LocalHandle),
    Docker(DockerHandle),
}

/// [Driver] implementation for [GenericDriver], calls out to [LocalDriver] or
/// [DockerDriver] depending on configuration.
#[async_trait]
impl Driver for GenericDriver {
    type Handle = GenericHandle;

    async fn run(&self, app: &str, opts: Options) -> anyhow::Result<Self::Handle> {
        let h = match self {
            GenericDriver::Local(d) => d.run(app, opts).await.map(GenericHandle::Local)?,
            GenericDriver::Docker(d) => d.run(app, opts).await.map(GenericHandle::Docker)?,
        };

        Ok(h)
    }

    async fn wait(&self, handle: &mut Self::Handle) -> anyhow::Result<()> {
        match (self, handle) {
            (GenericDriver::Local(d), GenericHandle::Local(h)) => d.wait(h).await?,
            (GenericDriver::Docker(d), GenericHandle::Docker(h)) => d.wait(h).await?,
            _ => panic!("driver/handler mismatch"),
        };
        Ok(())
    }

    async fn exit(&self, handle: Self::Handle) -> anyhow::Result<()> {
        match (self, handle) {
            (GenericDriver::Local(d), GenericHandle::Local(h)) => d.exit(h).await?,
            (GenericDriver::Docker(d), GenericHandle::Docker(h)) => d.exit(h).await?,
            _ => panic!("driver/handler mismatch"),
        };
        Ok(())
    }
}

================
File: sim/src/handle.rs
================
//! Speculos runtime handle, provides out-of-band interaction with a simulator instance
//! via the [HTTP API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/LedgerHQ/speculos/master/speculos/api/static/swagger/swagger.json) to allow button pushes and screenshots when executing integration tests.
//!
//!

use std::{io::Cursor, net::SocketAddr};

use async_trait::async_trait;
use image::{io::Reader as ImageReader, DynamicImage};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use strum::Display;
use tracing::debug;

use crate::GenericHandle;

/// Button enumeration
#[derive(Clone, Copy, PartialEq, Debug, Display)]
#[strum(serialize_all = "kebab-case")]
pub enum Button {
    Left,
    Right,
    Both,
}

/// Button actions
#[derive(Clone, Copy, PartialEq, Debug, Serialize, Deserialize, Display)]
#[serde(rename_all = "kebab-case")]
pub enum Action {
    Press,
    Release,
    PressAndRelease,
}

/// Button action object for serialisation and use with the HTTP API
#[derive(Clone, Copy, PartialEq, Debug, Serialize, Deserialize)]
struct ButtonAction {
    pub action: Action,
}

/// [Handle] trait for interacting with speculos
#[async_trait]
pub trait Handle {
    /// Get speculos HTTP address
    fn addr(&self) -> SocketAddr;

    /// Send a button action to the simulator
    async fn button(&self, button: Button, action: Action) -> anyhow::Result<()> {
        debug!("Sending button request: {}:{}", button, action);

        // Post action to HTTP API
        let r = Client::new()
            .post(format!("http://{}/button/{}", self.addr(), button))
            .json(&ButtonAction { action })
            .send()
            .await?;

        debug!("Button request complete: {}", r.status());

        Ok(())
    }

    /// Fetch a screenshot from the simulator
    async fn screenshot(&self) -> anyhow::Result<DynamicImage> {
        // Fetch screenshot from HTTP API
        let r = reqwest::get(format!("http://{}/screenshot", self.addr())).await?;

        // Read image bytes
        let b = r.bytes().await?;

        // Parse image object
        let i = ImageReader::new(Cursor::new(b))
            .with_guessed_format()?
            .decode()?;

        Ok(i)
    }
}

impl Handle for GenericHandle {
    fn addr(&self) -> SocketAddr {
        match self {
            GenericHandle::Local(h) => h.addr(),
            GenericHandle::Docker(h) => h.addr(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Check button string encoding
    #[test]
    fn button_encoding() {
        let tests = &[
            (Button::Left, "left"),
            (Button::Right, "right"),
            (Button::Both, "both"),
        ];

        for (v, s) in tests {
            assert_eq!(&v.to_string(), s);
        }
    }

    /// Check button action encoding
    #[test]
    fn action_encoding() {
        let tests = &[
            (
                ButtonAction {
                    action: Action::Press,
                },
                r#"{"action":"press"}"#,
            ),
            (
                ButtonAction {
                    action: Action::Release,
                },
                r#"{"action":"release"}"#,
            ),
            (
                ButtonAction {
                    action: Action::PressAndRelease,
                },
                r#"{"action":"press-and-release"}"#,
            ),
        ];

        for (v, s) in tests {
            assert_eq!(&serde_json::to_string(v).unwrap(), s);
        }
    }
}

================
File: sim/src/lib.rs
================
//! Rust wrapper for executing Speculos via local install or docker image,
//! provided to simplify CI/CD with ledger applications.
//!
//! Drivers are provided for [Docker](DockerDriver) and [Local](LocalDriver)
//! execution, with a [Generic](GenericDriver) abstraction to support
//! runtime driver selection.
//!
//! ### Examples:
//!
//! ``` no_run
//! # use tracing::{debug};
//! use ledger_sim::{GenericDriver, DriverMode, Driver, Model, Options};
//! use ledger_lib::{Device, transport::{Transport, TcpTransport, TcpInfo}, DEFAULT_TIMEOUT};
//! use ledger_proto::apdus::{AppInfoReq, AppInfoResp};
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     // Setup driver for speculos connection
//!     let driver = GenericDriver::new(DriverMode::Docker)?;
//!
//!     // Launch speculos with the provided app
//!     let opts = Options {
//!         model: Model::NanoX,
//!         apdu_port: Some(1237),
//!         ..Default::default()
//!     };
//!     let mut handle = driver.run("ledger-app", opts).await?;
//!
//!     // Setup TCP APDU transport to speculos
//!     let mut transport = TcpTransport::new()?;
//!     let mut device = transport.connect(TcpInfo::default()).await?;
//!
//!     // Fetch app info via transport
//!     let mut buff = [0u8; 256];
//!     let info = device.request::<AppInfoResp>(AppInfoReq{}, &mut buff, DEFAULT_TIMEOUT).await?;
//!
//!     // Await simulator exit or exit signal
//!     tokio::select!(
//!         // Await simulator task completion
//!         _ = driver.wait(&mut handle) => {
//!             debug!("Complete!");
//!         }
//!         // Exit on ctrl + c
//!         _ = tokio::signal::ctrl_c() => {
//!             debug!("Exit!");
//!             driver.exit(handle).await?;
//!         },
//!     );
//!
//!     Ok(())
//! }
//! ```

use std::collections::HashMap;

use clap::Parser;

use strum::{Display, EnumString, EnumVariantNames};

mod drivers;
pub use drivers::*;

mod handle;
pub use handle::*;

/// Device model
#[derive(Copy, Clone, PartialEq, Debug, EnumVariantNames, Display, EnumString)]
#[strum(serialize_all = "lowercase")]
pub enum Model {
    /// Nano S
    NanoS,
    /// Nano S Plus
    #[strum(serialize = "nanosplus", to_string = "nanosp")]
    NanoSP,
    /// Nano X
    NanoX,
}

impl Model {
    /// Fetch target name for a given ledger model
    pub fn target(&self) -> &'static str {
        match self {
            Model::NanoS => "nanos",
            Model::NanoSP => "nanosplus",
            Model::NanoX => "nanox",
        }
    }
}

/// Simulator display mode
#[derive(Copy, Clone, PartialEq, Debug, EnumVariantNames, Display, EnumString, clap::ValueEnum)]
#[strum(serialize_all = "lowercase")]
pub enum Display {
    /// Headless mode
    Headless,
    /// QT based rendering
    Qt,
    /// Text based (command line) rendering
    Text,
}

/// Simulator options
#[derive(Clone, PartialEq, Debug, Parser)]
pub struct Options {
    /// Model to simulate
    #[clap(long, default_value_t = Options::default().model)]
    pub model: Model,

    /// Display mode
    #[clap(long, value_enum, default_value_t = Options::default().display)]
    pub display: Display,

    /// SDK version override (defaults based on --model)
    #[clap(long)]
    pub sdk: Option<String>,

    /// API level override
    #[clap(long)]
    pub api_level: Option<String>,

    /// BIP39 seed for initialisation
    #[clap(long, env)]
    pub seed: Option<String>,

    /// Enable HTTP API port
    #[clap(long, default_value_t = Options::default().http_port)]
    pub http_port: u16,

    /// Enable APDU TCP port (usually 1237)
    #[clap(long, env)]
    pub apdu_port: Option<u16>,

    /// Enable debugging and wait for GDB connection (port 1234)
    #[clap(long)]
    pub debug: bool,

    /// Speculos root (used to configure python paths if set)
    #[clap(long, env = "SPECULOS_ROOT")]
    pub root: Option<String>,

    /// Trace syscalls
    #[clap(long)]
    pub trace: bool,
}

impl Default for Options {
    fn default() -> Self {
        Self {
            model: Model::NanoSP,
            display: Display::Headless,
            sdk: None,
            api_level: None,
            seed: None,
            http_port: 5000,
            apdu_port: None,
            debug: false,
            root: None,
            trace: false,
        }
    }
}

impl Options {
    /// Build an argument list from [Options]
    pub fn args(&self) -> Vec<String> {
        // Basic args
        let mut args = vec![
            format!("--model={}", self.model),
            format!("--display={}", self.display),
            format!("--api-port={}", self.http_port),
        ];

        if let Some(seed) = &self.seed {
            args.push(format!("--seed={seed}"));
        }

        if let Some(apdu_port) = &self.apdu_port {
            args.push(format!("--apdu-port={apdu_port}"));
        }

        if let Some(sdk) = &self.sdk {
            args.push(format!("--sdk={sdk}"));
        }

        if let Some(api_level) = &self.api_level {
            args.push(format!("--apiLevel={api_level}"));
        }

        if self.debug {
            args.push("--debug".to_string());
        }

        if self.trace {
            args.push("-t".to_string());
        }

        args
    }

    /// Build environmental variable list from [Options]
    pub fn env(&self) -> HashMap<String, String> {
        let mut env = HashMap::new();

        if let Some(seed) = &self.seed {
            env.insert("SPECULOS_SEED".to_string(), seed.clone());
        }

        env
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use crate::Model;

    #[test]
    fn model_name_encoding() {
        let t = &[
            (Model::NanoS, "nanos", "nanos"),
            (Model::NanoSP, "nanosp", "nanosp"),
            (Model::NanoSP, "nanosp", "nanosplus"),
            (Model::NanoX, "nanox", "nanox"),
        ];

        for (model, enc, dec) in t {
            assert_eq!(&model.to_string(), enc);
            assert_eq!(Ok(*model), Model::from_str(dec));
        }
    }
}

================
File: sim/src/main.rs
================
//! Rust ledger-sim example application, supports invoking speculos from the command line.

use clap::Parser;
use tracing::{debug, info};
use tracing_subscriber::{filter::LevelFilter, EnvFilter, FmtSubscriber};

use ledger_sim::*;

/// Ledger Speculos simulator wrapper tool
///
/// This calls out to a Docker or local speculos install
/// to provide a simple way of executing speculos in CI/CD.
#[derive(Clone, Debug, PartialEq, Parser)]
pub struct Args {
    /// Application to run
    app: String,

    /// Driver mode
    #[clap(long, value_enum, default_value = "docker")]
    driver: DriverMode,

    #[clap(flatten)]
    speculos_opts: Options,

    /// Log level
    #[clap(long, default_value = "debug")]
    log_level: LevelFilter,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Parse command line arguments
    let args = Args::parse();

    info!("Launching speculos...");

    // Setup logging
    // Setup logging
    let filter = EnvFilter::from_default_env()
        .add_directive("bollard=warn".parse()?)
        .add_directive(args.log_level.into());

    let _ = FmtSubscriber::builder()
        .compact()
        .without_time()
        .with_max_level(args.log_level)
        .with_env_filter(filter)
        .try_init();

    // Run with specified driver
    match args.driver {
        DriverMode::Local => {
            let d = LocalDriver::new();
            run_simulator(d, &args.app, args.speculos_opts).await?;
        }
        DriverMode::Docker => {
            let d = DockerDriver::new()?;
            run_simulator(d, &args.app, args.speculos_opts).await?;
        }
    }

    Ok(())
}

async fn run_simulator<D: Driver>(driver: D, app: &str, opts: Options) -> anyhow::Result<()> {
    // Start simulator
    let mut h = driver.run(app, opts).await?;

    // Await simulator exit or exit signal
    tokio::select!(
        // Await simulator task completion
        _ = driver.wait(&mut h) => {
            debug!("Complete!");
        }
        // Exit on ctrl + c
        _ = tokio::signal::ctrl_c() => {
            debug!("Exit!");
            driver.exit(h).await?;
        },
    );

    Ok(())
}

================
File: sim/Cargo.toml
================
[package]
name = "ledger-sim"
description = "A Rust wrapper for the Ledger Speculos Simulator"
repository = "https://github.com/ledger-community/rust-ledger.git"
keywords = [ "ledger", "hardware", "wallet", "speculos", "simulator" ]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"

[dependencies]
bytes = "1.2.1"
strum = { version = "0.24.1", features = [ "derive" ] }
anyhow = "1.0.59"
clap = { version = "4.3.1", features = [ "derive", "env" ] }
tokio = { version = "1.20.1", features = [ "full" ] }
lazy_static = "1.4.0"
tracing = "0.1.37"
tracing-subscriber = { version = "0.3.16", features = ["env-filter"] }
bollard = "0.13.0"
async-trait = "0.1.57"
futures = "0.3.24"
tar = "0.4.38"
reqwest = { version = "0.11.13", features = [ "json", "rustls-tls" ], default-features = false }
serde = "1.0.148"
serde_json = "1.0.89"
image = "0.24.5"

[dev-dependencies]
ledger-lib = "0.1.0"
ledger-proto = "0.1.0"

================
File: .gitignore
================
target/
Cargo.lock

================
File: Cargo.toml
================
[workspace]
resolver = "2"
members = [
    "proto",
    "lib",
    "sim",
    "cli",
]

[patch.crates-io]
ledger-proto = { path = "proto" }
ledger-lib = { path = "lib" }
ledger-sim = { path = "sim" }

================
File: README.md
================
# Ledger hardware wallet communication library

A rust-based library for interacting with Ledger hardware wallets.
This provides low-level USB/HID, BLE, and TCP/Speculos `Transport`s as well as a high level `LedgerProvider` interface that manages device connections using a pinned worker thread for use from async / tokio contexts.

## Status

[![CI](https://github.com/ledger-community/rust-ledger/actions/workflows/ci.yml/badge.svg)](https://github.com/ledger-community/rust-ledger/actions/workflows/ci.yml)
[![GitHub tag](https://img.shields.io/github/tag/ledger-community/ledger.svg)](https://github.com/ledger-community/rust-ledger)
[![Latest docs](https://img.shields.io/badge/docs-latest-blue)](https://ledger-community.github.io/rust-ledger/ledger_lib/index.html)

This project is under active development, if you run into bugs please feel free to open an issue or PR.

## Layout

- [ledger-lib](lib) provides a library for communication with ledger devices  
  [![Crates.io](https://img.shields.io/crates/v/ledger-lib.svg)](https://crates.io/crates/ledger-lib) [![Docs.rs](https://docs.rs/ledger-lib/badge.svg)](https://docs.rs/ledger-lib)
- [ledger-proto](proto) provides shared APDU / protocol traits and objects  
  [![Crates.io](https://img.shields.io/crates/v/ledger-proto.svg)](https://crates.io/crates/ledger-proto) [![Docs.rs](https://docs.rs/ledger-proto/badge.svg)](https://docs.rs/ledger-proto)
- [ledger-cli](cli) provides a simple command line utility for interacting with ledger devices  
  [![Crates.io](https://img.shields.io/crates/v/ledger-cli.svg)](https://crates.io/crates/ledger-cli) [![Docs.rs](https://docs.rs/ledger-cli/badge.svg)](https://docs.rs/ledger-cli)
- [ledger-sim](sim) provides a rust wrapper to simplify use of [Speculos] for CI/CD  
  [![Crates.io](https://img.shields.io/crates/v/ledger-sim.svg)](https://crates.io/crates/ledger-sim) [![Docs.rs](https://docs.rs/ledger-sim/badge.svg)](https://docs.rs/ledger-sim)


[speculos]: https://github.com/LedgerHQ/speculos
